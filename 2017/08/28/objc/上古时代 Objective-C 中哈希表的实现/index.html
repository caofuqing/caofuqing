<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>曹福清</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上古时代 Objective-C 中哈希表的实现 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。  写在前面文章会介绍上古时代 Objective-C 哈希表，也就是 NXHashTable ：  NXHashTable 的实现 NXHashTable 的性">
<meta name="keywords" content="曹福清 博客">
<meta property="og:type" content="article">
<meta property="og:title" content="曹福清">
<meta property="og:url" content="http://caofuqing.com/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/index.html">
<meta property="og:site_name" content="曹福清">
<meta property="og:description" content="上古时代 Objective-C 中哈希表的实现 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。  写在前面文章会介绍上古时代 Objective-C 哈希表，也就是 NXHashTable ：  NXHashTable 的实现 NXHashTable 的性">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-insert-empty.gif">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-insert-one.gif.gif">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-insert-many.gif.gif">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-hash-state-init.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-hashstate-next.gif">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-instrument.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-nsarray-instrument.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-copy-class-list.png">
<meta property="og:updated_time" content="2017-08-28T00:13:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="曹福清">
<meta name="twitter:description" content="上古时代 Objective-C 中哈希表的实现 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。  写在前面文章会介绍上古时代 Objective-C 哈希表，也就是 NXHashTable ：  NXHashTable 的实现 NXHashTable 的性">
<meta name="twitter:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-hashtable-insert-empty.gif">
  
    <link rel="alternate" href="/atom.xml" title="曹福清" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">曹福清</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://caofuqing.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-objc/上古时代 Objective-C 中哈希表的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="上古时代-Objective-C-中哈希表的实现"><a href="#上古时代-Objective-C-中哈希表的实现" class="headerlink" title="上古时代 Objective-C 中哈希表的实现"></a>上古时代 Objective-C 中哈希表的实现</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章会介绍上古时代 Objective-C 哈希表，也就是 <code>NXHashTable</code> ：</p>
<ul>
<li><code>NXHashTable</code> 的实现</li>
<li><code>NXHashTable</code> 的性能分析</li>
<li><code>NXHashTable</code> 的作用</li>
</ul>
<p><code>NXHashTable</code> 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。</p>
<blockquote>
<p>文中会涉及一些数据结构方面的简单知识，例如<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" target="_blank" rel="noopener">拉链法</a>。</p>
<p>注意：<strong>文章中分析的不是 <code>NSHashTable</code> 而是 <code>NXHashTable</code>。</strong></p>
</blockquote>
<h2 id="NXHashTable"><a href="#NXHashTable" class="headerlink" title="NXHashTable"></a>NXHashTable</h2><p><code>NXHashTable</code> 的实现位于 <code>hashtable2.mm</code> 文件，我们先来看一下 <code>NXHashTable</code> 的结构以及重要的接口：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> NXHashTablePrototype *prototype;</span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    <span class="keyword">unsigned</span> nbBuckets;</span><br><span class="line">    <span class="keyword">void</span> *buckets;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *info;</span><br><span class="line">&#125; NXHashTable;</span><br></pre></td></tr></table></figure>
<p>对于结构体中的 <code>NXHashTablePrototype</code> 属性暂且不说，其中的 <code>buckets</code> 是真正用来<strong>存储数据的数组</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z);</span><br><span class="line"><span class="keyword">unsigned</span> NXCountHashTable (NXHashTable *table);</span><br><span class="line"><span class="keyword">int</span> NXHashMember (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line"><span class="keyword">void</span> *NXHashGet (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line"><span class="keyword">void</span> *NXHashInsert (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line"><span class="keyword">void</span> *NXHashRemove (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br></pre></td></tr></table></figure>
<p>我们会以上面的这些方法作为切入点，分析 <code>NXHashTable</code> 的实现。</p>
<h3 id="NXCreateHashTableFromZone"><a href="#NXCreateHashTableFromZone" class="headerlink" title="NXCreateHashTableFromZone"></a>NXCreateHashTableFromZone</h3><p><code>NXHashTable</code> 使用 <code>NXCreateHashTableFromZone</code> 方法初始化：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z) &#123;</span><br><span class="line">    NXHashTable			*table;</span><br><span class="line">    NXHashTablePrototype	 *proto;</span><br><span class="line"></span><br><span class="line">    table = ALLOCTABLE(z);</span><br><span class="line">    <span class="keyword">if</span> (! prototypes) bootstrap ();</span><br><span class="line">    <span class="keyword">if</span> (! prototype.hash) prototype.hash = NXPtrHash;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.isEqual) prototype.isEqual = NXPtrIsEqual;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.free) prototype.free = NXNoEffectFree;</span><br><span class="line"></span><br><span class="line">    proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    <span class="keyword">if</span> (! proto) &#123;</span><br><span class="line">        proto = (NXHashTablePrototype *) malloc(<span class="keyword">sizeof</span> (NXHashTablePrototype));</span><br><span class="line">        bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;prototype, (<span class="keyword">char</span>*)proto, <span class="keyword">sizeof</span> (NXHashTablePrototype));</span><br><span class="line">        (<span class="keyword">void</span>) NXHashInsert (prototypes, proto);</span><br><span class="line">        proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    &#125;;</span><br><span class="line">    table-&gt;prototype = proto;</span><br><span class="line">    table-&gt;count = <span class="number">0</span>;</span><br><span class="line">    table-&gt;info = info;</span><br><span class="line">    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);</span><br><span class="line">    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，绝大多数代码都是用来初始化 <code>table-&gt;prototype</code> 的，我们先把这部分全部忽略，分析一下简略版本的实现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z) &#123;</span><br><span class="line">    NXHashTable			*table;</span><br><span class="line">    NXHashTablePrototype	 *proto;</span><br><span class="line"></span><br><span class="line">    table = ALLOCTABLE(z);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    table-&gt;count = <span class="number">0</span>;</span><br><span class="line">    table-&gt;info = info;</span><br><span class="line">    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);</span><br><span class="line">    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ALLOCTABLE</code>、<code>GOOD_CAPACITY</code> 以及 <code>ALLOCBUCKETS</code> 都是用来辅助初始化的宏：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define	 ALLOCTABLE(z) ((NXHashTable *) malloc_zone_malloc ((malloc_zone_t *)z,sizeof (NXHashTable)))</span></span><br><span class="line"><span class="meta">#define GOOD_CAPACITY(c) (exp2m1u (log2u (c)+1))</span></span><br><span class="line"><span class="meta">#define ALLOCBUCKETS(z,nb) ((HashBucket *) malloc_zone_calloc ((malloc_zone_t *)z, nb, sizeof (HashBucket)))</span></span><br></pre></td></tr></table></figure>
<p><code>ALLOCTABLE</code> 和 <code>ALLOCBUCKETS</code> 只是调用了 <code>malloc_zone_calloc</code> 来初始化相应的结构体，而 <code>GOOD_CAPACITY</code> 有一些特殊，我们来举个例子说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c   binary  result</span><br><span class="line">1   1       1 </span><br><span class="line">2   10      3(0b11)</span><br><span class="line">6   110     7(0b111)</span><br><span class="line">100 1100100 127(0b111 1111)</span><br></pre></td></tr></table></figure>
<p><code>c</code> 表示传入参数，<code>binary</code> 表示二进制下的参数，而 <code>result</code> 就是 <code>GOOD_CAPACITY</code> 返回的结果。</p>
<blockquote>
<p>每次返回当前位数下的二进制最大值。</p>
</blockquote>
<p>获得 <code>table-&gt;nbBuckets</code> 之后，再初始化 <code>table-&gt;nbBuckets * sizeof (HashBucket)</code> 大小的内存空间。</p>
<h4 id="NXHashTablePrototype"><a href="#NXHashTablePrototype" class="headerlink" title="NXHashTablePrototype"></a>NXHashTablePrototype</h4><p>在继续分析其它方法之前，我们需要先知道 <code>NXHashTablePrototype</code> 是什么：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    uintptr_t (*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> (*isEqual)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data1, <span class="keyword">const</span> <span class="keyword">void</span> *data2);</span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> style; <span class="comment">/* reserved for future expansion; currently 0 */</span></span><br><span class="line">&#125; NXHashTablePrototype;</span><br></pre></td></tr></table></figure>
<p><code>NXHashTablePrototype</code> 中存储了 <code>hash</code>、<code>isEqual</code> 和 <code>free</code> 的函数指针（用于获取数据的哈希、判断两个数据是否相等以及释放数据）。</p>
<p>在 <code>hashtable2.mm</code> 文件中有一个宏 <code>ISEQUAL</code> 就是用了 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 来判断两个数据是否相等：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISEQUAL(table, data1, data2) ((data1 == data2) || (*table-&gt;prototype-&gt;isEqual)(table-&gt;info, data1, data2))</span></span><br></pre></td></tr></table></figure>
<p>可以说，<code>NXHashTablePrototype</code> 中存储了一些<strong>构建哈希表必要的函数指针</strong>。</p>
<blockquote>
<p>因为 <code>NXHashTable</code> 使用<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" target="_blank" rel="noopener">拉链法</a>来实现哈希表，在存入表前对数据执行 hash，然后找到对应的 buckets，如果与 buckets 中的数据相同（使用 isEqual 判断），就替换原数据，否则将数据添加到链表中。</p>
</blockquote>
<h4 id="HashBucket"><a href="#HashBucket" class="headerlink" title="HashBucket"></a>HashBucket</h4><p>在这里另一个需要注意的数据结构就是 <code>HashBucket</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>	&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    oneOrMany elements;</span><br><span class="line">&#125; HashBucket;</span><br></pre></td></tr></table></figure>
<p><code>oneOrMany</code> 是一个 <code>union</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *one;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **many;</span><br><span class="line">&#125; oneOrMany;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这么设计的主要原因是<strong>提升性能</strong>。</p>
</blockquote>
<p>如果 <code>HashBucket</code> 中只有一个元素，那么就直接访问 <code>one</code>，否则访问 <code>many</code>，遍历这个 <code>many</code> 列表。</p>
<h3 id="NXCountHashTable"><a href="#NXCountHashTable" class="headerlink" title="NXCountHashTable"></a>NXCountHashTable</h3><p><code>NXCountHashTable</code> 方法应该是我们要介绍的方法中的最简单的一个，它会直接返回 <code>NXHashTable</code> 结构体中的 <code>count</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> NXCountHashTable (NXHashTable *table) &#123;</span><br><span class="line">    <span class="keyword">return</span> table-&gt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NXHashMember"><a href="#NXHashMember" class="headerlink" title="NXHashMember"></a>NXHashMember</h3><p><code>NXHashMember</code> 的函数签名虽然会返回 <code>int</code>，其实它是一个布尔值，会判断当前的 <code>NXHashTable</code> 中是否包含传入的数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NXHashMember (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket	*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>	j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one);</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>BUCKETOF</code> 对 <code>data</code> 进行 hash，将结果与哈希表的 <code>buckets</code> 数取模，返回 <code>buckets</code> 数组中对应的 <code>NXHashBucket</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define BUCKETOF(table, data) (((HashBucket *)table-&gt;buckets)+((*table-&gt;prototype-&gt;hash)(table-&gt;info, data) % table-&gt;nbBuckets))</span></span><br></pre></td></tr></table></figure>
<p>在获取了 <code>bucket</code> 之后，根据其中元素个数的不同，选择不同的分支：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one);</span><br><span class="line">&#125;;</span><br><span class="line">pairs = bucket-&gt;elements.many;</span><br><span class="line"><span class="keyword">while</span> (j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    pairs ++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>count == 0</code>，直接返回</li>
<li><code>count == 1</code>，使用 <code>ISEQUAL</code> 比较查找的数据与 <code>bucket-&gt;elements.one</code> </li>
<li><p><code>count &gt; 1</code>，依次与 <code>bucket-&gt;elements.many</code> 中的值进行比较</p>
<blockquote>
<p>你可能觉得到这里的时间复杂度比较糟糕，然而这个列表并不会很长，具体会在 <a href="#nxhashinsert">NXHashInsert</a> 中解释。</p>
</blockquote>
</li>
</ul>
<h3 id="NXHashGet"><a href="#NXHashGet" class="headerlink" title="NXHashGet"></a>NXHashGet</h3><blockquote>
<p>其实我一直觉得这个方法可能用处不是很大，尤其是在使用默认的 <code>NXHashTablePrototype</code> 时，因为默认的 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 函数指针只是比较两个数据的指针是否相同。</p>
<p>其最大作用就是查看当前 <code>data</code> 是不是在表中。</p>
<p>如果当前数据在表中，那么这个方法只会返回一个相同的指针，没有太多的意义。</p>
</blockquote>
<p>它的实现跟上面的 <code>NXHashMember</code> 区别并不大，这里就不过多介绍了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *NXHashGet (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket	*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>	j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one)</span><br><span class="line">        ? (<span class="keyword">void</span> *) bucket-&gt;elements.one : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> (<span class="keyword">void</span> *) *pairs;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NXHashInsert"><a href="#NXHashInsert" class="headerlink" title="NXHashInsert"></a>NXHashInsert</h3><p><code>NXHashInsert</code> 是 <code>NXHashTable</code> 中比较重要的方法，其作用就是向表中插入数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *NXHashInsert (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket *bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span> j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **pairs;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **newt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) &#123;</span><br><span class="line">        bucket-&gt;count++;</span><br><span class="line">        bucket-&gt;elements.one = data;</span><br><span class="line">        table-&gt;count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, bucket-&gt;elements.one)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span> *old = bucket-&gt;elements.one;</span><br><span class="line">            bucket-&gt;elements.one = data;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">        newt[<span class="number">1</span>] = bucket-&gt;elements.one;</span><br><span class="line">        *newt = data;</span><br><span class="line">        bucket-&gt;count++;</span><br><span class="line">        bucket-&gt;elements.many = newt;</span><br><span class="line">        table-&gt;count++;</span><br><span class="line">        <span class="keyword">if</span> (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>	*old = *pairs;</span><br><span class="line">            *pairs = data;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    newt = ALLOCPAIRS(z, bucket-&gt;count+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;count) bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)bucket-&gt;elements.many, (<span class="keyword">char</span>*)(newt+<span class="number">1</span>), bucket-&gt;count * PTRSIZE);</span><br><span class="line">    *newt = data;</span><br><span class="line">    FREEPAIRS (bucket-&gt;elements.many);</span><br><span class="line">    bucket-&gt;count++; </span><br><span class="line">    bucket-&gt;elements.many = newt;</span><br><span class="line">    table-&gt;count++;</span><br><span class="line">    <span class="keyword">if</span> (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这里的实现比上面的两个方法复杂得多，但是脉络仍然很清晰，我们将插入的过程分为三种情况：</p>
<ul>
<li><code>bucket-&gt;count == 0</code></li>
<li><code>bucket-&gt;count == 1</code></li>
<li><code>bucket-&gt;count &gt; 1</code></li>
</ul>
<p>如果对应的 <code>bucket</code> 为空：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! j) &#123;</span><br><span class="line">    bucket-&gt;count++; </span><br><span class="line">    bucket-&gt;elements.one = data;</span><br><span class="line">    table-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将数据直接填入 <code>bucket</code>，增加 <code>bucket</code> 中元素的数目，以及 <code>table</code> 中存储的元素的数目：</p>
<p><img src="../images/objc-hashtable-insert-empty.gif" alt="objc-hashtable-insert-empty"></p>
<p>如果原来的 <code>buckets</code> 中有一个元素，它会替换或者使用 <code>many</code> 替换原来的 <code>one</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, data, bucket-&gt;elements.one)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>	*old = bucket-&gt;elements.one;</span><br><span class="line">        bucket-&gt;elements.one = data;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">    newt[<span class="number">1</span>] = bucket-&gt;elements.one;</span><br><span class="line">    *newt = data;</span><br><span class="line">    bucket-&gt;count++;</span><br><span class="line">    bucket-&gt;elements.many = newt;</span><br><span class="line">    table-&gt;count++;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当前数据 <code>data</code> 如果与 <code>bucket</code> 中存储的数据相同，就会更新这个数据，否则就会使用 <code>ALLOCPAIRS</code> 初始化一个新的数组，然后将 <code>data</code> 和原来的数据传入。</p>
<p><img src="../images/objc-hashtable-insert-one.gif.gif" alt="objc-hashtable-insert-one.gif"></p>
<p>但是如果原来的 <code>bucket</code> 中存储的元素大于 1，那么会在链表的头部追加一个新的元素：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>	*old = *pairs;</span><br><span class="line">        *pairs = data;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs ++;</span><br><span class="line">&#125;;</span><br><span class="line">newt = ALLOCPAIRS(z, bucket-&gt;count+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (bucket-&gt;count) bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)bucket-&gt;elements.many, (<span class="keyword">char</span>*)(newt+<span class="number">1</span>), bucket-&gt;count * PTRSIZE);</span><br><span class="line">*newt = data;</span><br><span class="line">FREEPAIRS (bucket-&gt;elements.many);</span><br><span class="line">bucket-&gt;count++;</span><br><span class="line">bucket-&gt;elements.many = newt;</span><br><span class="line">table-&gt;count++;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用 <code>bcopy</code> 将原链表中元素拷贝到新的数组 <code>newt</code> 中。</p>
<p><img src="../images/objc-hashtable-insert-many.gif.gif" alt="objc-hashtable-insert-many.gif"></p>
<p>在每次添加完一个元素之后，都会进行下面的判断：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的这行代码会保证<strong>哈希表中的元素数据小于等于表中的 bucket 数量</strong>。</p>
</blockquote>
<p>这就是 <code>buckets</code> 后面的列表非常短的原因，在理想情况下，<strong>每一个 <code>buckets</code> 中都只存储一个或零个元素</strong>。</p>
<h4 id="NXHashRehash"><a href="#NXHashRehash" class="headerlink" title="_NXHashRehash"></a>_NXHashRehash</h4><p>如果哈希表在添加元素后，其中的数据多于 <code>buckets</code> 数量，就会对 <code>NXHashTable</code> 进行 <code>_NXHashRehash</code> 操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _NXHashRehash (NXHashTable *table) &#123;</span><br><span class="line">    _NXHashRehashToCapacity (table, MORE_CAPACITY(table-&gt;nbBuckets));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用 <code>_NXHashRehashToCapacity</code> 方法来扩大 <code>NXHashTable</code> 的容量（<code>HashBucket</code> 的个数）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MORE_CAPACITY(b) (b*2+1)</span></span><br></pre></td></tr></table></figure>
<p>而 <code>MORE_CAPACITY</code> 会将当前哈希表的容量翻倍，并将新的容量传入 <code>_NXHashRehashToCapacity</code> 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _NXHashRehashToCapacity (NXHashTable *table, <span class="keyword">unsigned</span> newCapacity) &#123;</span><br><span class="line">    NXHashTable	*old;</span><br><span class="line">    NXHashState	state;</span><br><span class="line">    <span class="keyword">void</span>	*aux;</span><br><span class="line">    __unused <span class="keyword">void</span> *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    old = ALLOCTABLE(z);</span><br><span class="line">    old-&gt;prototype = table-&gt;prototype; old-&gt;count = table-&gt;count;</span><br><span class="line">    old-&gt;nbBuckets = table-&gt;nbBuckets; old-&gt;buckets = table-&gt;buckets;</span><br><span class="line">    table-&gt;nbBuckets = newCapacity;</span><br><span class="line">    table-&gt;count = <span class="number">0</span>; table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);</span><br><span class="line">    state = NXInitHashState (old);</span><br><span class="line">    <span class="keyword">while</span> (NXNextHashState (old, &amp;state, &amp;aux))</span><br><span class="line">        (<span class="keyword">void</span>) NXHashInsert (table, aux);</span><br><span class="line">    freeBuckets (old, <span class="literal">NO</span>);</span><br><span class="line">    </span><br><span class="line">    free (old-&gt;buckets);</span><br><span class="line">    free (old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 <code>NXHashTable</code> 的指针指向原哈希表</li>
<li>改变哈希表的 <code>nbBuckets</code>，并重新初始化哈希表的 <code>buckets</code> 数组</li>
<li>重新将元素插入到哈希表中</li>
<li>释放原哈希表 <code>old</code> 以及 <code>buckets</code></li>
</ol>
<h4 id="NXHashState"><a href="#NXHashState" class="headerlink" title="NXHashState"></a>NXHashState</h4><p>在将元素重新插入到哈希表中涉及了一个非常奇怪的结构体 <code>NXHashState</code>，这个结构体主要作用是遍历 <code>NXHashTable</code> 中的元素。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125; NXHashState;</span><br></pre></td></tr></table></figure>
<p>我们可以使用如下的代码对哈希表中的元素进行遍历：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">MyData	 *data;</span><br><span class="line">NXHashState state = NXInitHashState(table);</span><br><span class="line"><span class="keyword">while</span> (NXNextHashState(table, &amp;state, &amp;data)) &#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码片段中调用了两个方法，分别是 <code>NXInitHashState</code> 以及 <code>NXNextHashState</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NXHashState NXInitHashState (NXHashTable *table) &#123;</span><br><span class="line">    NXHashState	state;</span><br><span class="line"></span><br><span class="line">    state.i = table-&gt;nbBuckets;</span><br><span class="line">    state.j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NXInitHashState</code> 会将 <code>NXHashState</code> 指向哈希表的最末端：</p>
<p><img src="../images/objc-hashtable-hash-state-init.png" alt="objc-hashtable-hash-state-init"></p>
<blockquote>
<p>这个位置其实并不属于 <code>NXHashTable</code>，它一定会为空。</p>
</blockquote>
<p>而每次调用 <code>NXNextHashState</code> 都会向『前』移动一次：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NXNextHashState (NXHashTable *table, NXHashState *state, <span class="keyword">void</span> **data) &#123;</span><br><span class="line">    HashBucket		*buckets = (HashBucket *) table-&gt;buckets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (state-&gt;j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        state-&gt;i--; state-&gt;j = buckets[state-&gt;i].count;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;j--;</span><br><span class="line">    buckets += state-&gt;i;</span><br><span class="line">    *data = (<span class="keyword">void</span> *) ((buckets-&gt;count == <span class="number">1</span>)</span><br><span class="line">                      ? buckets-&gt;elements.one : buckets-&gt;elements.many[state-&gt;j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面的 gif 为我们展示了每一次调用 <code>NXNextHashState</code> 方法之后当前的 <code>NXHashState</code>：</p>
<p><img src="../images/objc-hashtable-hashstate-next.gif" alt="objc-hashtable-hashstate-next"></p>
<h3 id="NXHashRemove"><a href="#NXHashRemove" class="headerlink" title="NXHashRemove"></a>NXHashRemove</h3><p>这里的 <code>NXHashRemove</code>在某种意义上是 <code>NXHashInsert</code> 的逆操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *NXHashRemove (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket	*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>	j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**pairs;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**newt;</span><br><span class="line">    __unused <span class="keyword">void</span> *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! ISEQUAL(table, data, bucket-&gt;elements.one)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        data = bucket-&gt;elements.one;</span><br><span class="line">        table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.one = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) data;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, pairs[<span class="number">0</span>])) &#123;</span><br><span class="line">            bucket-&gt;elements.one = pairs[<span class="number">1</span>]; data = pairs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ISEQUAL(table, data, pairs[<span class="number">1</span>])) &#123;</span><br><span class="line">            bucket-&gt;elements.one = pairs[<span class="number">0</span>]; data = pairs[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        FREEPAIRS (pairs);</span><br><span class="line">        table-&gt;count--; bucket-&gt;count--;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) data;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) &#123;</span><br><span class="line">            data = *pairs;</span><br><span class="line">            <span class="comment">/* we shrink this bucket */</span></span><br><span class="line">            newt = (bucket-&gt;count<span class="number">-1</span>)</span><br><span class="line">            ? ALLOCPAIRS(z, bucket-&gt;count<span class="number">-1</span>) : <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (bucket-&gt;count<span class="number">-1</span> != j)</span><br><span class="line">                bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)bucket-&gt;elements.many, (<span class="keyword">char</span>*)newt, PTRSIZE*(bucket-&gt;count-j<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)(bucket-&gt;elements.many + bucket-&gt;count-j), (<span class="keyword">char</span>*)(newt+bucket-&gt;count-j<span class="number">-1</span>), PTRSIZE*j);</span><br><span class="line">            FREEPAIRS (bucket-&gt;elements.many);</span><br><span class="line">            table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.many = newt;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *) data;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的实现也分为三种情况，不过在这里就不多说了。</p>
<h2 id="NXHashTable-的性能"><a href="#NXHashTable-的性能" class="headerlink" title="NXHashTable 的性能"></a>NXHashTable 的性能</h2><p>在已经熟悉了 <code>NXHashTable</code> 的具体实现之后，我们要分析插入<strong>不同数据量级</strong>的情况下，所需要的时间，这里是主程序的代码，分别测试了在 <code>100, 1000, 10000, 100000, 1000000, 2000000, 3000000, 5000000, 10000000</code> 数据下 <code>NXHashTable</code> 的性能表现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"hashtable2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *capacities = @[</span><br><span class="line">            @<span class="number">100</span>,</span><br><span class="line">            @<span class="number">1000</span>,</span><br><span class="line">            @<span class="number">10000</span>,</span><br><span class="line">            @<span class="number">100000</span>,</span><br><span class="line">            @<span class="number">1000000</span>,</span><br><span class="line">            @<span class="number">2000000</span>,</span><br><span class="line">            @<span class="number">3000000</span>,</span><br><span class="line">            @<span class="number">5000000</span>,</span><br><span class="line">            @<span class="number">10000000</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *capacity <span class="keyword">in</span> capacities) &#123;</span><br><span class="line">            NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">NSDate</span> *methodStart = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; capacity.integerValue; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, (<span class="keyword">long</span>)i];</span><br><span class="line">                NXHashInsert(hashTable, (__bridge <span class="keyword">void</span> *)value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSDate</span> *methodFinish = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="built_in">NSTimeInterval</span> executionTime = [methodFinish timeIntervalSinceDate:methodStart];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Capacities: %@, executionTime = %f, meanTime = %.10f"</span>, capacity, executionTime, executionTime / capacity.integerValue);</span><br><span class="line"></span><br><span class="line">            free(hashTable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中初始化了一个 <code>capacities</code> 存储需要测量的数据量级，然后调用 <code>NXHashInsert</code> 方法将相当数量级的数据添加到哈希表中：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000334</td>
<td style="text-align:right">0.0000033402</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.001962</td>
<td style="text-align:right">0.0000019619</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.022001</td>
<td style="text-align:right">0.0000022001</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.349998</td>
<td style="text-align:right">0.0000035000</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">2.622551</td>
<td style="text-align:right">0.0000026226</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">4.165023</td>
<td style="text-align:right">0.0000020825</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">6.973098</td>
<td style="text-align:right">0.0000023244</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">13.179743</td>
<td style="text-align:right">0.0000026359</td>
</tr>
<tr>
<td style="text-align:right"><strong>10000000</strong></td>
<td style="text-align:right"><strong>53.387356</strong></td>
<td style="text-align:right"><strong>0.0000053387</strong></td>
</tr>
</tbody>
</table>
<p>在对 <code>NXHashTable</code> 的性能测试中，当数据量小于 5000000 时，执行时间的增长还是线性的，平均时间也基本稳定，但是一旦数据量达到了千万级，执行时间就会出现显著的增长。</p>
<p>如果仅仅在哈希表中插入数据，相信其时间增长应该都是线性的，这里出现问题的原因推测是<strong>在对哈希表进行 Rehash 的时候，迁移原数据至新的数组所造成的</strong>。</p>
<p>如何避免哈希表的 Rehash 呢，重新回顾一下创建哈希表的函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTable (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br></pre></td></tr></table></figure>
<p>这个函数的签名中包含一个 <code>capacity</code> 的参数，我们在上面的代码中传入了 0，也就是最开始的 <code>buckets</code> 数为 0，但是它的数目并不是固定的，它会随着哈希表中数据的增多，逐渐变大。</p>
<blockquote>
<p><code>capacity</code> 只是一个提示，帮助 NXHashTable 了解其中会存储多少数据。</p>
</blockquote>
<p>如果在创建 <code>NXHashTable</code> 时传入 <code>capacity.integerValue</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, capacity.integerValue, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>重新运行代码，测量性能：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000740</td>
<td style="text-align:right">0.0000073999</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.003442</td>
<td style="text-align:right">0.0000034420</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.023341</td>
<td style="text-align:right">0.0000023341</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.215209</td>
<td style="text-align:right">0.0000021521</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">1.836802</td>
<td style="text-align:right">0.0000018368</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">3.683246</td>
<td style="text-align:right">0.0000018416</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">5.474610</td>
<td style="text-align:right">0.0000018249</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">10.576254</td>
<td style="text-align:right">0.0000021153</td>
</tr>
<tr>
<td style="text-align:right">10000000</td>
<td style="text-align:right">46.725459</td>
<td style="text-align:right">0.0000046725</td>
</tr>
</tbody>
</table>
<p>虽然在测试 <code>10,000,000</code> 数据时其平均时间依然是 <code>5,000,000</code> 时的二倍，不过整体的性能都有所提升，然而这部分性能的损耗暂时还不是很清楚原因。</p>
<p>如果我们使用 Instrument 对有无 <code>capacity</code> 的情况进行比较（这是在使用 <code>2,000,000</code> 数据时进行的测试）：</p>
<p><img src="../images/objc-hashtable-instrument.png" alt="objc-hashtable-instrument"></p>
<p>没有传入 <code>capacity</code> 的哈希表会在多次插入之后出现一个峰值（由于 Rehash 引起的，其宽度就是 Rehash 使用的时间），而传入 <code>capacity</code> 的哈希表会在代码刚运行时就初始化足够大的数组。</p>
<h2 id="NSMutableArray-性能"><a href="#NSMutableArray-性能" class="headerlink" title="NSMutableArray 性能"></a>NSMutableArray 性能</h2><blockquote>
<p>这部分只算是一个小插曲，你可以选择跳过这一小节的内容。</p>
</blockquote>
<p><code>NSMutableArray</code> 的构造器 <code>- (instancetype)initWithCapacity:(NSUInteger)numItems</code> 也有一个参数 <code>capacity</code>，虽然数组和哈希表是两种数据结构。</p>
<blockquote>
<p>不过我们这里主要研究的是：<strong>传入 <code>capacity</code> 是否会对性能造成影响</strong>。</p>
</blockquote>
<p>首先是使用 <code>init</code> 创建的 <code>NSMutableArray</code> 数组，也就是没有传入 <code>capacity</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000539</td>
<td style="text-align:right">0.0000053900</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.003185</td>
<td style="text-align:right">0.0000031850</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.074033</td>
<td style="text-align:right">0.0000074033</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.370899</td>
<td style="text-align:right">0.0000037090</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">1.504855</td>
<td style="text-align:right">0.0000015049</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">2.852519</td>
<td style="text-align:right">0.0000014263</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">3.995536</td>
<td style="text-align:right">0.0000013318</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">6.833879</td>
<td style="text-align:right">0.0000013668</td>
</tr>
<tr>
<td style="text-align:right">10000000</td>
<td style="text-align:right">14.444605</td>
<td style="text-align:right">0.0000014445</td>
</tr>
</tbody>
</table>
<p>下面是使用 <code>initWithCapacity:</code> 创建的数组：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000256</td>
<td style="text-align:right">0.0000025600</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.001775</td>
<td style="text-align:right">0.0000017750</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.015906</td>
<td style="text-align:right">0.0000015906</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.174376</td>
<td style="text-align:right">0.0000017438</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">1.650481</td>
<td style="text-align:right">0.0000016505</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">2.802310</td>
<td style="text-align:right">0.0000014012</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">4.451261</td>
<td style="text-align:right">0.0000014838</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">7.093753</td>
<td style="text-align:right">0.0000014188</td>
</tr>
<tr>
<td style="text-align:right">10000000</td>
<td style="text-align:right">14.598415</td>
<td style="text-align:right">0.0000014598</td>
</tr>
</tbody>
</table>
<p>你可以在表格中看到，两者在执行效率上并没有显著的差异或者区别。</p>
<p>但是如果使用 instrument 来查看两者的内存分配，可以很明显的看到，没有传入 <code>capacity</code> 的 <code>NSMutableArray</code> 会在可变数组内存占用增加前出现一个<strong>短暂的内存分配峰值</strong>。</p>
<p><img src="../images/objc-hashtable-nsarray-instrument.png" alt="objc-hashtable-nsarray-instrument"></p>
<p>导致这一现象的原始可能是：在将原数组中的内容移入新数组时，<strong>临时变量申请了大量的内存空间</strong>。</p>
<blockquote>
<p>在之后关于 CoreFoundation 源代码分析的文中会介绍它们是怎么实现的。</p>
</blockquote>
<h2 id="NXHashTable-的应用"><a href="#NXHashTable-的应用" class="headerlink" title="NXHashTable 的应用"></a>NXHashTable 的应用</h2><p>在整个 objc/runtime 中，作为<strong>私有</strong>的数据结构 <code>NXHashTable</code>，直接使用了它的就是<strong>存储所有类或者元类</strong>的哈希表（在这里会忽略对元类的存储，因为实现几乎完全相同）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NXHashTable *realized_class_hash = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>objc_copyClassList</code> 获取类的数组：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class *</span><br><span class="line">objc_copyClassList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    realizeAllClasses();</span><br><span class="line"></span><br><span class="line">    Class *result = <span class="literal">nil</span>;</span><br><span class="line">    NXHashTable *classes = realizedClasses();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = NXCountHashTable(classes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        NXHashState state = NXInitHashState(classes);</span><br><span class="line">        result = (Class *)malloc((<span class="number">1</span>+count) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (NXNextHashState(classes, &amp;state, (<span class="keyword">void</span> **)&amp;cls)) &#123;</span><br><span class="line">            result[count++] = cls;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = count;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <code>realizedClasses</code> 返回 <code>realized_class_hash</code> 哈希表</li>
<li>使用 <code>NSHashState</code> 遍历 <code>realized_class_hash</code> 中的类，并将所有的类存入 <code>result</code></li>
</ol>
<p>接下来使用上面的方法，打印出 <code>realized_class_hash</code> 中存储的所有类：</p>
<p><img src="../images/objc-hashtable-copy-class-list.png" alt="objc-hashtable-copy-class-list"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p><code>NXHashTable</code> 在 OS X 10.1 中就已经标记为弃用了，但是依旧支持着 runtime 底层的工作。</p>
</blockquote>
<p><code>NXHashTable</code> 可以说有着<strong>非常非常</strong>久远的历史了，最早可以追溯到将近 30 多年前 NeXT 时代：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashtable2.mm 文件中</span></span><br><span class="line"></span><br><span class="line">hashtable2.m</span><br><span class="line">Copyright <span class="number">1989</span><span class="number">-1996</span> NeXT Software, Inc.</span><br><span class="line">Created by Bertrand Serlet, Feb <span class="number">89</span></span><br></pre></td></tr></table></figure>
<p><code>NSHashTable</code> 对哈希表的实现还是非常优雅的，可以说非常标准的使用了<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" target="_blank" rel="noopener">拉链法</a>实现哈希表。</p>
<p>不过现在，我们会使用 <code>NSHashTable</code> 来取代这个上古时代的产物。</p>
<blockquote>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">Draveness · Github</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/" data-id="cjw6zovu90002bn043i7r3wml" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/27/iOS面试题整理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          iOS面试题整理
        
      </div>
    </a>
  
  
    <a href="/2017/08/28/objc/从源代码看 ObjC 中消息的发送/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/27/hello-world/">Hello World caofuqing</a>
          </li>
        
          <li>
            <a href="/2019/05/27/iOS面试题整理/">iOS面试题整理</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/从源代码看 ObjC 中消息的发送/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/你真的了解 load 方法么？/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 talking<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>