<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>曹福清</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="从源代码看 ObjC 中消息的发送 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。  写在前面如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：  在 Objective">
<meta name="keywords" content="曹福清 博客">
<meta property="og:type" content="article">
<meta property="og:title" content="曹福清">
<meta property="og:url" content="http://caofuqing.com/2017/08/28/objc/从源代码看 ObjC 中消息的发送/index.html">
<meta property="og:site_name" content="曹福清">
<meta property="og:description" content="从源代码看 ObjC 中消息的发送 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。  写在前面如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：  在 Objective">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-core.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-selector.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-selector-undefined.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-find-selector-before-init.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-wrong-step-in.gif">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-youtube-preview.jpg">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-first-call-hello.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-cache-struct.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-step-in-cache-getimp.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-first-call-hello.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-objc-msgSend-with-cache.gif">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-before-flush-cache.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-after-flush-cache.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-after-flush-cache-trap-in-lookup-again.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-add-imp-to-cache.png">
<meta property="og:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-run-after-add-cache.png">
<meta property="og:updated_time" content="2017-08-28T00:13:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="曹福清">
<meta name="twitter:description" content="从源代码看 ObjC 中消息的发送 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。  写在前面如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：  在 Objective">
<meta name="twitter:image" content="http://caofuqing.com/2017/08/28/objc/images/objc-message-core.png">
  
    <link rel="alternate" href="/atom.xml" title="曹福清" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">曹福清</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://caofuqing.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-objc/从源代码看 ObjC 中消息的发送" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/从源代码看 ObjC 中消息的发送/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="从源代码看-ObjC-中消息的发送"><a href="#从源代码看-ObjC-中消息的发送" class="headerlink" title="从源代码看 ObjC 中消息的发送"></a>从源代码看 ObjC 中消息的发送</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：</p>
<ol>
<li>在 Objective-C 中的“方法调用”其实应该叫做消息传递</li>
<li><code>[receiver message]</code> 会被翻译为 <code>objc_msgSend(receiver, @selector(message))</code></li>
<li>在消息的响应链中<strong>可能</strong>会调用 <code>- resolveInstanceMethod:</code> <code>- forwardInvocation:</code> 等方法</li>
<li><p>关于选择子 SEL 的知识</p>
<blockquote>
<p>如果对于上述的知识不够了解，可以看一下这篇文章 <a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a>，但是其中关于 <code>objc_class</code> 的结构体的代码已经过时了，不过不影响阅读以及理解。</p>
</blockquote>
</li>
<li><p>方法在内存中存储的位置，<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a>（可选）</p>
<blockquote>
<p>文章中不会刻意区别方法和函数、消息传递和方法调用之间的区别。</p>
</blockquote>
</li>
<li><p>能翻墙（会有一个 Youtube 的链接）</p>
</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>关于 Objective-C 中的消息传递的文章真的是太多了，而这篇文章又与其它文章有什么不同呢？</p>
<p>由于这个系列的文章都是对 Objective-C 源代码的分析，所以会<strong>从 Objective-C 源代码中分析并合理地推测一些关于消息传递的问题</strong>。</p>
<p><img src="../images/objc-message-core.png" alt="objc-message-core"></p>
<h2 id="关于-selector-你需要知道的"><a href="#关于-selector-你需要知道的" class="headerlink" title="关于 @selector() 你需要知道的"></a>关于 @selector() 你需要知道的</h2><p>因为在 Objective-C 中，所有的消息传递中的“消息“都会被转换成一个 <code>selector</code> 作为 <code>objc_msgSend</code> 函数的参数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object hello] -&gt; objc_msgSend(object, <span class="keyword">@selector</span>(hello))</span><br></pre></td></tr></table></figure>
<p>这里面使用 <code>@selector(hello)</code> 生成的选择子 <strong>SEL</strong> 是这一节中关注的重点。</p>
<p>我们需要预先解决的问题是：使用 <code>@selector(hello)</code> 生成的选择子，是否会因为类的不同而不同？各位读者可以自己思考一下。</p>
<p>先放出结论：使用 <code>@selector()</code> 生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了。也就是说<strong>向不同的类发送相同的消息时，其生成的选择子是完全相同的</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XXObject *xx = [[XXObject alloc] init]</span><br><span class="line">YYObject *yy = [[YYObject alloc] init]</span><br><span class="line">objc_msgSend(xx, <span class="keyword">@selector</span>(hello))</span><br><span class="line">objc_msgSend(yy, <span class="keyword">@selector</span>(hello))</span><br></pre></td></tr></table></figure>
<p>接下来，我们开始验证这一结论的正确性，这是程序主要包含的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数任意位置打一个断点， 比如 <code>-&gt; [object hello];</code> 这里，然后在 lldb 中输入：</p>
<p><img src="../images/objc-message-selector.png" alt="objc-message-selecto"></p>
<p>这里面我们打印了两个选择子的地址<code>@selector(hello)</code> 以及 <code>@selector(undefined_hello_method)</code>，需要注意的是：</p>
<blockquote>
<p><code>@selector(hello)</code> 是在编译期间就声明的选择子，而后者在编译期间并不存在，<code>undefined_hello_method</code> 选择子由于是在运行时生成的，所以内存地址明显比 <code>hello</code> 大很多</p>
</blockquote>
<p>如果我们修改程序的代码：</p>
<p><img src="../images/objc-message-selector-undefined.png" alt="objc-message-selector-undefined"></p>
<p>在这里，由于我们在代码中显示地写出了 <code>@selector(undefined_hello_method)</code>，所以在 lldb 中再次打印这个 <code>sel</code> 内存地址跟之前相比有了很大的改变。</p>
<p>更重要的是，我没有通过指针的操作来获取 <code>hello</code> 选择子的内存地址，而只是通过 <code>@selector(hello)</code> 就可以返回一个选择子。</p>
<p>从上面的这些现象，可以推断出选择子有以下的特性：</p>
<ol>
<li>Objective-C 为我们维护了一个巨大的选择子表</li>
<li>在使用 <code>@selector()</code> 时会从这个选择子表中根据选择子的名字查找对应的 <code>SEL</code>。如果没有找到，则会生成一个 <code>SEL</code> 并添加到表中</li>
<li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 <code>@selector()</code> 生成的选择子加入到选择子表中</li>
</ol>
<p>在运行时初始化之前，打印 <code>hello</code> 选择子的的内存地址：</p>
<p><img src="../images/objc-message-find-selector-before-init.png" alt="objc-message-find-selector-before-init"></p>
<h2 id="message-h-文件"><a href="#message-h-文件" class="headerlink" title="message.h 文件"></a>message.h 文件</h2><p>Objective-C 中 <code>objc_msgSend</code> 的实现并没有开源，它只存在于 <code>message.h</code> 这个头文件中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @note When it encounters a method call, the compiler generates a call to one of the</span></span><br><span class="line"><span class="comment"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</span></span><br><span class="line"><span class="comment"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;</span></span><br><span class="line"><span class="comment"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</span></span><br><span class="line"><span class="comment"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>在这个头文件的注释中对<strong>消息发送的一系列方法</strong>解释得非常清楚：</p>
<blockquote>
<p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 <code>objc_msgSend</code>、<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code> 和 <code>objc_msgSendSuper_stret</code>。<br>发送给对象的父类的消息会使用 <code>objc_msgSendSuper</code><br>有数据结构作为返回值的方法会使用 <code>objc_msgSendSuper_stret</code> 或 <code>objc_msgSend_stret</code><br>其它的消息都是使用 <code>objc_msgSend</code> 发送的</p>
</blockquote>
<p>在这篇文章中，我们只会对<strong>消息发送的过程</strong>进行分析，而不会对<strong>上述消息发送方法的区别</strong>进行分析，默认都使用 <code>objc_msgSend</code> 函数。</p>
<h2 id="objc-msgSend-调用栈"><a href="#objc-msgSend-调用栈" class="headerlink" title="objc_msgSend 调用栈"></a>objc_msgSend 调用栈</h2><p>这一小节会以向 <code>XXObject</code> 的实例发送 <code>hello</code> 消息为例，在 Xcode 中观察整个消息发送的过程中调用栈的变化，再来看一下程序的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>hello</code> 方法的这一行打一个断点，当我们尝试进入（Step in）这个方法只会直接跳入这个方法的实现，而不会进入 <code>objc_msgSend</code>：</p>
<p><img src="../images/objc-message-wrong-step-in.gif" alt="objc-message-wrong-step-in"></p>
<p>因为 <code>objc_msgSend</code> 是一个私有方法，我们没有办法进入它的实现，但是，我们却可以在 <code>objc_msgSend</code> 的调用栈中“截下”这个函数调用的过程。</p>
<p>调用 <code>objc_msgSend</code> 时，传入了 <code>self</code> 以及 <code>SEL</code> 参数。</p>
<p>既然要执行对应的方法，肯定要寻找选择子对应的实现。</p>
<p>在 <code>objc-runtime-new.mm</code> 文件中有一个函数 <code>lookUpImpOrForward</code>，这个函数的作用就是查找方法的实现，于是运行程序，在运行到 <code>hello</code> 这一行时，激活 <code>lookUpImpOrForward</code> 函数中的断点。</p>
<p><a href="https://youtu.be/bCdjdI4VhwQ" target="_blank"><img src="../images/objc-message-youtube-preview.jpg"></a></p>
<blockquote>
<p>由于转成 gif 实在是太大了，笔者试着用各种方法生成动图，然而效果也不是很理想，只能贴一个 Youtube 的视频链接，不过对于能够翻墙的开发者们，应该也不是什么问题吧（手动微笑）</p>
</blockquote>
<p>如果跟着视频看这个方法的调用栈有些混乱的话，也是正常的。在下一个节中会对其调用栈进行详细的分析。</p>
<h1 id="解析-objc-msgSend"><a href="#解析-objc-msgSend" class="headerlink" title="解析 objc_msgSend"></a>解析 objc_msgSend</h1><p>对 <code>objc_msgSend</code> 解析总共分两个步骤，我们会向 <code>XXObject</code> 的实例发送两次 <code>hello</code> 消息，分别模拟无缓存和有缓存两种情况下的调用栈。</p>
<h2 id="无缓存"><a href="#无缓存" class="headerlink" title="无缓存"></a>无缓存</h2><p>在 <code>-&gt; [object hello]</code> 这里增加一个断点，<strong>当程序运行到这一行时</strong>，再向 <code>lookUpImpOrForward</code> 函数的第一行添加断点，确保是捕获 <code>@selector(hello)</code> 的调用栈，而不是调用其它选择子的调用栈。</p>
<p><img src="../images/objc-message-first-call-hello.png" alt="objc-message-first-call-hello"></p>
<p>由图中的变量区域可以了解，传入的选择子为 <code>&quot;hello&quot;</code>，对应的类是 <code>XXObject</code>。所以我们可以确信这就是当调用 <code>hello</code> 方法时执行的函数。在 Xcode 左侧能看到方法的调用栈：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> lookUpImpOrForward</span><br><span class="line"><span class="number">1</span> _class_lookupMethodAndLoadCache3</span><br><span class="line"><span class="number">2</span> objc_msgSend</span><br><span class="line"><span class="number">3</span> main</span><br><span class="line"><span class="number">4</span> start</span><br></pre></td></tr></table></figure>
<p>调用栈在这里告诉我们： <code>lookUpImpOrForward</code> 并不是 <code>objc_msgSend</code> 直接调用的，而是通过 <code>_class_lookupMethodAndLoadCache3</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(<span class="keyword">id</span> obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj,</span><br><span class="line">                              <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">NO</span><span class="comment">/*cache*/</span>, <span class="literal">YES</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个<strong>仅提供给派发器（dispatcher）</strong>用于方法查找的函数，其它的代码都应该使用 <code>lookUpImpOrNil()</code>（不会进行方法转发）。<code>_class_lookupMethodAndLoadCache3</code> 会传入 <code>cache = NO</code> 避免在<strong>没有加锁</strong>的时候对缓存进行查找，因为派发器已经做过这件事情了。</p>
<h3 id="实现的查找-lookUpImpOrForward"><a href="#实现的查找-lookUpImpOrForward" class="headerlink" title="实现的查找 lookUpImpOrForward"></a>实现的查找 lookUpImpOrForward</h3><p>由于实现的查找方法 <code>lookUpImpOrForward</code> 涉及很多函数的调用，所以我们将它分成以下几个部分来分析：</p>
<ol>
<li>无锁的缓存查找</li>
<li>如果类没有实现（isRealized）或者初始化（isInitialized），实现或者初始化类</li>
<li>加锁</li>
<li>缓存以及当前类中方法的查找</li>
<li>尝试查找父类的缓存以及方法列表</li>
<li>没有找到实现，尝试方法解析器</li>
<li>进行消息转发</li>
<li>解锁、返回实现</li>
</ol>
<h4 id="无锁的缓存查找"><a href="#无锁的缓存查找" class="headerlink" title="无锁的缓存查找"></a>无锁的缓存查找</h4><p>下面是在没有加锁的时候对缓存进行查找，提高缓存使用的性能：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optimistic cache lookup</span></span><br><span class="line"><span class="keyword">if</span> (cache) &#123;</span><br><span class="line">   imp = cache_getImp(cls, sel);</span><br><span class="line">   <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过因为 <code>_class_lookupMethodAndLoadCache3</code> 传入的 <code>cache = NO</code>，所以这里会直接跳过 if 中代码的执行，在 <code>objc_msgSend</code> 中已经使用汇编代码查找过了。</p>
<h4 id="类的实现和初始化"><a href="#类的实现和初始化" class="headerlink" title="类的实现和初始化"></a>类的实现和初始化</h4><p>在 <em>Objective-C 运行时</em> 初始化的过程中会对其中的类进行第一次初始化也就是执行 <code>realizeClass</code> 方法，为类分配可读写结构体 <code>class_rw_t</code> 的空间，并返回正确的类结构体。</p>
<p>而 <code>_class_initialize</code> 方法会调用类的 <code>initialize</code> 方法，我会在之后的文章中对类的初始化进行分析。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line">    realizeClass(cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>加锁这一部分只有一行简单的代码，其主要目的保证方法查找以及缓存填充（cache-fill）的原子性，保证在运行以下代码时不会有<strong>新方法添加导致缓存被冲洗（flush）</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.read();</span><br></pre></td></tr></table></figure>
<h4 id="在当前类中查找实现"><a href="#在当前类中查找实现" class="headerlink" title="在当前类中查找实现"></a>在当前类中查找实现</h4><p>实现很简单，先调用了 <code>cache_getImp</code> 从某个类的 <code>cache</code> 属性中获取选择子对应的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imp = cache_getImp(cls, sel);</span><br><span class="line"><span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-message-cache-struct.png" alt="objc-message-cache-struct"></p>
<p>不过 <code>cache_getImp</code> 的实现目测是不开源的，同时也是汇编写的，在我们尝试 step in 的时候进入了如下的汇编代码。</p>
<p><img src="../images/objc-message-step-in-cache-getimp.png" alt="objc-message-step-in-cache-getimp"></p>
<p>它会进入一个 <code>CacheLookup</code> 的标签，获取实现，使用汇编的原因还是因为要加速整个实现查找的过程，其原理推测是在类的 <code>cache</code> 中寻找对应的实现，只是做了一些性能上的优化。</p>
<p>如果查找到实现，就会跳转到 <code>done</code> 标签，因为我们在这个小结中的假设是无缓存的（第一次调用 <code>hello</code> 方法），所以会进入下面的代码块，从类的方法列表中寻找方法的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line"><span class="keyword">if</span> (meth) &#123;</span><br><span class="line">    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">    imp = meth-&gt;imp;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>getMethodNoSuper_nolock</code> 方法查找对应的方法的结构体指针 <code>method_t</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *getMethodNoSuper_nolock(Class cls, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),</span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists();</span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        method_t *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类中数据的方法列表 <code>methods</code> 是一个二维数组 <code>method_array_t</code>，写一个 <code>for</code> 循环遍历整个方法列表，而这个 <code>search_method_list</code> 的实现也特别简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *search_method_list(<span class="keyword">const</span> method_list_t *mlist, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="keyword">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(method_t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findMethodInSortedMethodList</code> 方法对有序方法列表进行线性探测，返回方法结构体 <code>method_t</code>。</p>
<p>如果在这里找到了方法的实现，将它加入类的缓存中，这个操作最后是由 <code>cache_fill_nolock</code> 方法来完成的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> cache_fill_nolock(Class cls, SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line">    cache_key_t key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    mask_t newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    mask_t capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket_t *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果缓存中的内容大于容量的 <code>3/4</code> 就会扩充缓存，使缓存的大小翻倍。</p>
<blockquote>
<p>在缓存翻倍的过程中，当前类<strong>全部的缓存都会被清空</strong>，Objective-C 出于性能的考虑不会将原有缓存的 <code>bucket_t</code> 拷贝到新初始化的内存中。</p>
</blockquote>
<p>找到第一个空的 <code>bucket_t</code>，以 <code>(SEL, IMP)</code> 的形式填充进去。</p>
<h4 id="在父类中寻找实现"><a href="#在父类中寻找实现" class="headerlink" title="在父类中寻找实现"></a>在父类中寻找实现</h4><p>这一部分与上面的实现基本上是一样的，只是多了一个循环用来判断根类：</p>
<ol>
<li>查找缓存</li>
<li>搜索方法列表</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curClass = cls;</span><br><span class="line"><span class="keyword">while</span> ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">    imp = cache_getImp(curClass, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">            log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与当前类寻找实现的区别是：在父类中寻找到的 <code>_objc_msgForward_impcache</code> 实现会交给当前类来处理。</p>
<h4 id="方法决议"><a href="#方法决议" class="headerlink" title="方法决议"></a>方法决议</h4><p>选择子在当前类和父类中都没有找到实现，就进入了方法决议（method resolve）的过程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    _class_resolveMethod(cls, sel, inst);</span><br><span class="line">    triedResolver = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码调用 <code>_class_resolveMethod</code> 来解析没有找到实现的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, <span class="keyword">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst,</span><br><span class="line">                            <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据当前的类是不是<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">元类</a>在 <code>_class_resolveInstanceMethod</code> 和 <code>_class_resolveClassMethod</code> 中选择一个进行调用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, <span class="keyword">id</span> inst) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls,</span><br><span class="line">                         <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) &#123;</span><br><span class="line">        <span class="comment">// 没有找到 resolveInstanceMethod: 方法，直接返回。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (__typeof__(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存结果，以防止下次在调用 resolveInstanceMethod: 方法影响性能。</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst,</span><br><span class="line">                             <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法的实现其实就是判断当前类是否实现了 <code>resolveInstanceMethod:</code> 或者 <code>resolveClassMethod:</code> 方法，然后用 <code>objc_msgSend</code> 执行上述方法，并传入需要决议的选择子。</p>
<blockquote>
<p>关于 <code>resolveInstanceMethod</code> 之后可能会写一篇文章专门介绍，不过关于这个方法的文章也确实不少，在 Google 上搜索会有很多的文章。</p>
</blockquote>
<p>在执行了 <code>resolveInstanceMethod:</code> 之后，会跳转到 retry 标签，<strong>重新执行查找方法实现的流程</strong>，只不过不会再调用 <code>resolveInstanceMethod:</code> 方法了（将 <code>triedResolver</code> 标记为 <code>YES</code>）。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>在缓存、当前类、父类以及 <code>resolveInstanceMethod:</code> 都没有解决实现查找的问题时，Objective-C 还为我们提供了最后一次翻身的机会，进行方法转发：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure>
<p>返回实现 <code>_objc_msgForward_impcache</code>，然后加入缓存。</p>
<p>====</p>
<p>这样就结束了整个方法第一次的调用过程，缓存没有命中，但是在当前类的方法列表中找到了 <code>hello</code> 方法的实现，调用了该方法。</p>
<p><img src="../images/objc-message-first-call-hello.png" alt="objc-message-first-call-hello"></p>
<h2 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h2><p>如果使用对应的选择子时，缓存命中了，那么情况就大不相同了，我们修改主程序中的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在第二次调用 <code>hello</code> 方法时，加一个断点：</p>
<p><img src="../images/objc-message-objc-msgSend-with-cache.gif" alt="objc-message-objc-msgSend-with-cache"></p>
<p><code>objc_msgSend</code> 并没有走 <code>lookupImpOrForward</code> 这个方法，而是直接结束，打印了另一个 <code>hello</code> 字符串。</p>
<p>我们如何确定 <code>objc_msgSend</code> 的实现到底是什么呢？其实我们没有办法来<strong>确认</strong>它的实现，因为这个函数的实现使用汇编写的，并且实现是不开源的。</p>
<p>不过，我们需要确定它是否真的<strong>访问了类中的缓存</strong>来加速实现寻找的过程。</p>
<p>好，现在重新运行程序至第二个 <code>hello</code> 方法调用之前：</p>
<p><img src="../images/objc-message-before-flush-cache.png" alt="objc-message-before-flush-cache"></p>
<p>打印缓存中 bucket 的内容：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)[XXObject <span class="keyword">class</span>]</span><br><span class="line">(objc_class *) $<span class="number">0</span> = <span class="number">0x0000000100001230</span></span><br><span class="line">(lldb) p (cache_t *)<span class="number">0x0000000100001240</span></span><br><span class="line">(cache_t *) $<span class="number">1</span> = <span class="number">0x0000000100001240</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(cache_t) $<span class="number">2</span> = &#123;</span><br><span class="line">  _buckets = <span class="number">0x0000000100604bd0</span></span><br><span class="line">  _mask = <span class="number">3</span></span><br><span class="line">  _occupied = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>capacity()</span><br><span class="line">(mask_t) $<span class="number">3</span> = <span class="number">4</span></span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">0</span>]</span><br><span class="line">(bucket_t) $<span class="number">4</span> = &#123;</span><br><span class="line">  _key = <span class="number">0</span></span><br><span class="line">  _imp = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">1</span>]</span><br><span class="line">(bucket_t) $<span class="number">5</span> = &#123;</span><br><span class="line">  _key = <span class="number">0</span></span><br><span class="line">  _imp = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">2</span>]</span><br><span class="line">(bucket_t) $<span class="number">6</span> = &#123;</span><br><span class="line">  _key = <span class="number">4294971294</span></span><br><span class="line">  _imp = <span class="number">0x0000000100000e60</span> (debug-objc`-[XXObject hello] at XXObject.m:<span class="number">17</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">3</span>]</span><br><span class="line">(bucket_t) $<span class="number">7</span> = &#123;</span><br><span class="line">  _key = <span class="number">4300169955</span></span><br><span class="line">  _imp = <span class="number">0x00000001000622e0</span> (libobjc.A.dylib`-[<span class="built_in">NSObject</span> init] at <span class="built_in">NSObject</span>.mm:<span class="number">2216</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个缓存中只有对 <code>hello</code> 和 <code>init</code> 方法实现的缓存，我们要将其中 <code>hello</code> 的缓存清空：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr $<span class="number">2.</span>buckets()[<span class="number">2</span>] = $<span class="number">2.</span>buckets()[<span class="number">1</span>]</span><br><span class="line">(bucket_t) $<span class="number">8</span> = &#123;</span><br><span class="line">  _key = <span class="number">0</span></span><br><span class="line">  _imp = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-message-after-flush-cache.png" alt="objc-message-after-flush-cache"></p>
<p>这样 <code>XXObject</code> 中就不存在 <code>hello</code> 方法对应实现的缓存了。然后继续运行程序：</p>
<p><img src="../images/objc-message-after-flush-cache-trap-in-lookup-again.png" alt="objc-message-after-flush-cache-trap-in-lookup-again"></p>
<p>虽然第二次调用 <code>hello</code> 方法，但是因为我们清除了 <code>hello</code> 的缓存，所以，会再次进入 <code>lookupImpOrForward</code> 方法。</p>
<p>下面会换一种方法验证猜测：<strong>在 hello 调用之前添加缓存</strong>。</p>
<p>添加一个新的实现 <code>cached_imp</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __unused IMP cached_imp = imp_implementationWithBlock(^() &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Cached Hello"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将以 <code>@selector(hello), cached_imp</code> 为键值对，将其添加到类结构体的缓存中，这里的实现 <code>cached_imp</code> 有一些区别，它会打印 <code>@&quot;Cached Hello&quot;</code> 而不是 <code>@&quot;Hello&quot;</code> 字符串：</p>
<p>在第一个 <code>hello</code> 方法调用之前将实现加入缓存：</p>
<p><img src="../images/objc-message-add-imp-to-cache.png" alt="objc-message-add-imp-to-cache"></p>
<p>然后继续运行代码：</p>
<p><img src="../images/objc-message-run-after-add-cache.png" alt="objc-message-run-after-add-cache"></p>
<p>可以看到，我们虽然没有改变 <code>hello</code> 方法的实现，但是在 <strong>objc_msgSend</strong> 的消息发送链路中，使用错误的缓存实现 <code>cached_imp</code> 拦截了实现的查找，打印出了 <code>Cached Hello</code>。</p>
<p>由此可以推定，<code>objc_msgSend</code> 在实现中确实检查了缓存。如果没有缓存会调用 <code>lookupImpOrForward</code> 进行方法查找。</p>
<p>为了提高消息传递的效率，ObjC 对 <code>objc_msgSend</code> 以及  <code>cache_getImp</code> 使用了汇编语言来编写。</p>
<p>如果你想了解有关 <code>objc_msgSend</code> 方法的汇编实现的信息，可以看这篇文章 <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html" target="_blank" rel="noopener">Let’s Build objc_msgSend</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章与其说是讲 ObjC 中的消息发送的过程，不如说是讲方法的实现是如何查找的。</p>
<p>Objective-C 中实现查找的路径还是比较符合直觉的：</p>
<ol>
<li>缓存命中</li>
<li>查找当前类的缓存及方法</li>
<li>查找父类的缓存及方法</li>
<li>方法决议</li>
<li>消息转发</li>
</ol>
<p>文章中关于方法调用栈的视频最开始是用 gif 做的，不过由于 gif 时间较长，试了很多的 gif 转换器，都没有得到一个较好的质量和合适的大小，所以最后选择用一个 Youtube 的视频。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html" target="_blank" rel="noopener">Let’s Build objc_msgSend</a></li>
</ul>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/从源代码看 ObjC 中消息的发送/" data-id="cjw6zovua0003bn0412ls24qw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/08/28/objc/你真的了解 load 方法么？/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/27/hello-world/">Hello World caofuqing</a>
          </li>
        
          <li>
            <a href="/2019/05/27/iOS面试题整理/">iOS面试题整理</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/从源代码看 ObjC 中消息的发送/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/你真的了解 load 方法么？/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 talking<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>