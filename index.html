<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>曹福清</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="曹福清的博客网站">
<meta name="keywords" content="曹福清 博客">
<meta property="og:type" content="website">
<meta property="og:title" content="曹福清">
<meta property="og:url" content="http://caofuqing.com/index.html">
<meta property="og:site_name" content="曹福清">
<meta property="og:description" content="曹福清的博客网站">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="曹福清">
<meta name="twitter:description" content="曹福清的博客网站">
  
    <link rel="alternate" href="/atom.xml" title="曹福清" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">曹福清</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://caofuqing.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/27/hello-world/" class="article-date">
  <time datetime="2019-05-27T13:06:04.194Z" itemprop="datePublished">2019-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/27/hello-world/">Hello World caofuqing</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2019/05/27/hello-world/" data-id="cjw6zovtl0000bn04qsepn59b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS面试题整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/27/iOS面试题整理/" class="article-date">
  <time datetime="2019-05-27T09:33:20.000Z" itemprop="datePublished">2019-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/27/iOS面试题整理/">iOS面试题整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>面试 iOS 开发时，切入点很重要，不同的切入点会导致不同的结果，没有找到合适的切入点也无法对应聘者有一个全面的了解。所以这份面试问题列表更多的是提供方向，没有固定的答案，而且可以根据应聘者的回应引出更多有意思深层次的讨论。</p>
<p>如果有不错的问题，欢迎联系追加</p>
<h2 id="一般性问题"><a href="#一般性问题" class="headerlink" title="一般性问题"></a>一般性问题</h2><ul>
<li>最近这两天你有学到什么知识/技能么？</li>
<li>最近有做过比较酷或者比较有挑战的项目么？</li>
<li>最近看过的书/文章有哪些？</li>
<li>如何向一个只接触过互联网的孩子解释「电视」？</li>
<li>为什么要学习编程，编程对你而言的乐趣在哪儿？</li>
<li>如果一个函数10次中有7次正确，3次错误，问题可能出现在哪里？</li>
<li>自身最大优点是什么，怎么证明？</li>
<li>有没有在 GitHub 上发布过开源代码，参与过开源项目？</li>
<li>你最近遇到过的一个技术挑战是什么？怎么解决的？</li>
<li>开发常用的工具有哪些？</li>
<li>熟悉 CocoaPods 么？能大概讲一下工作原理么？</li>
<li>最常用的版本控制工具是什么，能大概讲讲原理么？</li>
<li>今年你最想掌握的一门技术是什么？为什么？目前已经做到了哪个程度？</li>
<li>你一般是怎么用 Instruments 的？</li>
<li>你一般是如何调试 Bug 的？</li>
<li>你在你的项目中用到了哪些设计模式？</li>
<li>如何实现单例，单例会有什么弊端？</li>
<li>iOS 是如何管理内存的？</li>
</ul>
<h2 id="知识性问题"><a href="#知识性问题" class="headerlink" title="知识性问题"></a>知识性问题</h2><ul>
<li>什么是响应链，它是怎么工作的？</li>
<li>如何访问并修改一个类的私有属性？</li>
<li>iOS Extension 是什么？能列举几个常用的 Extension 么？</li>
<li>如何把一个包含自定义对象的数组序列化到磁盘？</li>
<li>Apple Pay 是什么？它的大概工作流程是怎样的？</li>
<li>iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？</li>
<li>iOS 的签名机制大概是怎样的？</li>
<li>iOS 7的多任务添加了哪两个新的 API? 各自的使用场景是什么？</li>
<li>Objective-C 的 <code>class</code> 是如何实现的？<code>Selector</code> 是如何被转化为 C 语言的函数调用的？</li>
<li><code>UIScrollView</code> 大概是如何实现的，它是如何捕捉、响应手势的？</li>
<li>Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？</li>
<li><code>+load</code> 和 <code>+initialize</code> 的区别是什么？</li>
<li>如何让 Category 支持属性？</li>
<li><code>NSOperation</code> 相比于 GCD 有哪些优势？</li>
<li><code>strong</code> / <code>weak</code> / <code>unsafe_unretained</code> 的区别？</li>
<li>如何为 Class 定义一个对外只读对内可读写的属性?</li>
<li>Objective-C 中，meta-class 指的是什么？</li>
<li><code>UIView</code> 和 <code>CALayer</code> 之间的关系？</li>
<li><code>+[UIView animateWithDuration:animations:completion:]</code> 内部大概是如何实现的？</li>
<li>什么时候会发生「隐式动画」？</li>
<li>如何处理异步的网络请求？</li>
<li><code>frame</code> 和 <code>bounds</code> 的区别是什么？</li>
<li>如何把一张大图缩小为1/4大小的缩略图？</li>
<li>一个 App 会处于哪些状态？</li>
<li>Push Notification 是如何工作的？</li>
<li>什么是 Runloop？</li>
<li>Toll-Free Bridging 是什么？什么情况下会使用？</li>
<li>当系统出现内存警告时会发生什么？</li>
<li>什么是 <code>Protocol</code>，Delegate 一般是怎么用的？</li>
<li>autorelease 对象在什么情况下会被释放？</li>
<li>UIWebView 有哪些性能问题？有没有可替代的方案。</li>
<li>为什么 NotificationCenter 要 removeObserver? 如何实现自动 remove?</li>
<li>当 <code>TableView</code> 的 <code>Cell</code> 改变时，如何让这些改变以动画的形式呈现？</li>
<li>什么是 <code>Method Swizzle</code>，什么情况下会使用？</li>
</ul>
<h2 id="经验类问题"><a href="#经验类问题" class="headerlink" title="经验类问题"></a>经验类问题</h2><ul>
<li>为什么 <code>UIScrollView</code> 的滚动会导致 <code>NSTimer</code> 失效？</li>
<li>为什么当 Core Animation 完成时，layer 又会恢复到原先的状态？</li>
<li>你会如何存储用户的一些敏感信息，如登录的 token。</li>
<li>有用过一些开源组件吧，能简单说几个么，大概说说它们的使用场景实现。</li>
<li>什么时候会发生 <code>EXC BAD ACCESS</code> 异常？</li>
<li>什么时候会使用 Core Graphics，有什么注意事项么？</li>
<li>NSNotification 和 KVO 的使用场景？</li>
<li>使用 Block 时需要注意哪些问题？</li>
<li><code>performSelector:withObject:afterDelay:</code> 内部大概是怎么实现的，有什么注意事项么？</li>
<li>如何播放 GIF 图片，有什么优化方案么？</li>
<li>使用 <code>NSUserDefaults</code> 时，如何处理布尔的默认值？(比如返回 NO，不知道是真的 NO 还是没有设置过)</li>
<li>有哪几种方式可以对图片进行缩放，使用 CoreGraphics 缩放时有什么注意事项？</li>
<li>哪些途径可以让 ViewController 瘦下来？</li>
<li>有哪些常见的 Crash 场景？</li>
</ul>
<h2 id="综合类问题"><a href="#综合类问题" class="headerlink" title="综合类问题"></a>综合类问题</h2><ul>
<li>设计一个可以无限滚动并且支持自动滚动的 SlideShow。</li>
<li>设计一个进度条。</li>
<li>设计一套大文件（如上百M的视频）下载方案。</li>
<li>如果让你来实现 <code>dispatch_once</code>，你会怎么做？</li>
<li>设计一个类似 iOS 主屏可以下拉出现 Spotlight 的系统。(对 UIScrollView 的理解程度)</li>
</ul>
<h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><ul>
<li>简述<a href="https://www.jianshu.com/p/2e1b3f54b4f3" target="_blank" rel="noopener">「Snakes and Ladders」</a>的实现思路(这道题比较容易阐述清楚，且难度适中)</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://way2ios.com/development/ios-development-2/iphone-interview-question-answers/" target="_blank" rel="noopener">http://way2ios.com/development/ios-development-2/iphone-interview-question-answers/</a></li>
<li><a href="https://blackpixel.com/writing/2013/04/interview-questions-for-ios-and-mac-developers-1.html" target="_blank" rel="noopener">https://blackpixel.com/writing/2013/04/interview-questions-for-ios-and-mac-developers-1.html</a></li>
<li><a href="https://github.com/CameronBanga/iOS-Developer-and-Designer-Interview-Questions" target="_blank" rel="noopener">https://github.com/CameronBanga/iOS-Developer-and-Designer-Interview-Questions</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2019/05/27/iOS面试题整理/" data-id="cjw6zovto0001bn042idv2uc8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-objc/上古时代 Objective-C 中哈希表的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="上古时代-Objective-C-中哈希表的实现"><a href="#上古时代-Objective-C-中哈希表的实现" class="headerlink" title="上古时代 Objective-C 中哈希表的实现"></a>上古时代 Objective-C 中哈希表的实现</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>文章会介绍上古时代 Objective-C 哈希表，也就是 <code>NXHashTable</code> ：</p>
<ul>
<li><code>NXHashTable</code> 的实现</li>
<li><code>NXHashTable</code> 的性能分析</li>
<li><code>NXHashTable</code> 的作用</li>
</ul>
<p><code>NXHashTable</code> 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。</p>
<blockquote>
<p>文中会涉及一些数据结构方面的简单知识，例如<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" target="_blank" rel="noopener">拉链法</a>。</p>
<p>注意：<strong>文章中分析的不是 <code>NSHashTable</code> 而是 <code>NXHashTable</code>。</strong></p>
</blockquote>
<h2 id="NXHashTable"><a href="#NXHashTable" class="headerlink" title="NXHashTable"></a>NXHashTable</h2><p><code>NXHashTable</code> 的实现位于 <code>hashtable2.mm</code> 文件，我们先来看一下 <code>NXHashTable</code> 的结构以及重要的接口：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> NXHashTablePrototype *prototype;</span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    <span class="keyword">unsigned</span> nbBuckets;</span><br><span class="line">    <span class="keyword">void</span> *buckets;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *info;</span><br><span class="line">&#125; NXHashTable;</span><br></pre></td></tr></table></figure>
<p>对于结构体中的 <code>NXHashTablePrototype</code> 属性暂且不说，其中的 <code>buckets</code> 是真正用来<strong>存储数据的数组</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z);</span><br><span class="line"><span class="keyword">unsigned</span> NXCountHashTable (NXHashTable *table);</span><br><span class="line"><span class="keyword">int</span> NXHashMember (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line"><span class="keyword">void</span> *NXHashGet (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line"><span class="keyword">void</span> *NXHashInsert (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line"><span class="keyword">void</span> *NXHashRemove (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br></pre></td></tr></table></figure>
<p>我们会以上面的这些方法作为切入点，分析 <code>NXHashTable</code> 的实现。</p>
<h3 id="NXCreateHashTableFromZone"><a href="#NXCreateHashTableFromZone" class="headerlink" title="NXCreateHashTableFromZone"></a>NXCreateHashTableFromZone</h3><p><code>NXHashTable</code> 使用 <code>NXCreateHashTableFromZone</code> 方法初始化：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z) &#123;</span><br><span class="line">    NXHashTable			*table;</span><br><span class="line">    NXHashTablePrototype	 *proto;</span><br><span class="line"></span><br><span class="line">    table = ALLOCTABLE(z);</span><br><span class="line">    <span class="keyword">if</span> (! prototypes) bootstrap ();</span><br><span class="line">    <span class="keyword">if</span> (! prototype.hash) prototype.hash = NXPtrHash;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.isEqual) prototype.isEqual = NXPtrIsEqual;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.free) prototype.free = NXNoEffectFree;</span><br><span class="line"></span><br><span class="line">    proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    <span class="keyword">if</span> (! proto) &#123;</span><br><span class="line">        proto = (NXHashTablePrototype *) malloc(<span class="keyword">sizeof</span> (NXHashTablePrototype));</span><br><span class="line">        bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;prototype, (<span class="keyword">char</span>*)proto, <span class="keyword">sizeof</span> (NXHashTablePrototype));</span><br><span class="line">        (<span class="keyword">void</span>) NXHashInsert (prototypes, proto);</span><br><span class="line">        proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    &#125;;</span><br><span class="line">    table-&gt;prototype = proto;</span><br><span class="line">    table-&gt;count = <span class="number">0</span>;</span><br><span class="line">    table-&gt;info = info;</span><br><span class="line">    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);</span><br><span class="line">    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，绝大多数代码都是用来初始化 <code>table-&gt;prototype</code> 的，我们先把这部分全部忽略，分析一下简略版本的实现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z) &#123;</span><br><span class="line">    NXHashTable			*table;</span><br><span class="line">    NXHashTablePrototype	 *proto;</span><br><span class="line"></span><br><span class="line">    table = ALLOCTABLE(z);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    table-&gt;count = <span class="number">0</span>;</span><br><span class="line">    table-&gt;info = info;</span><br><span class="line">    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);</span><br><span class="line">    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ALLOCTABLE</code>、<code>GOOD_CAPACITY</code> 以及 <code>ALLOCBUCKETS</code> 都是用来辅助初始化的宏：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define	 ALLOCTABLE(z) ((NXHashTable *) malloc_zone_malloc ((malloc_zone_t *)z,sizeof (NXHashTable)))</span></span><br><span class="line"><span class="meta">#define GOOD_CAPACITY(c) (exp2m1u (log2u (c)+1))</span></span><br><span class="line"><span class="meta">#define ALLOCBUCKETS(z,nb) ((HashBucket *) malloc_zone_calloc ((malloc_zone_t *)z, nb, sizeof (HashBucket)))</span></span><br></pre></td></tr></table></figure>
<p><code>ALLOCTABLE</code> 和 <code>ALLOCBUCKETS</code> 只是调用了 <code>malloc_zone_calloc</code> 来初始化相应的结构体，而 <code>GOOD_CAPACITY</code> 有一些特殊，我们来举个例子说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c   binary  result</span><br><span class="line">1   1       1 </span><br><span class="line">2   10      3(0b11)</span><br><span class="line">6   110     7(0b111)</span><br><span class="line">100 1100100 127(0b111 1111)</span><br></pre></td></tr></table></figure>
<p><code>c</code> 表示传入参数，<code>binary</code> 表示二进制下的参数，而 <code>result</code> 就是 <code>GOOD_CAPACITY</code> 返回的结果。</p>
<blockquote>
<p>每次返回当前位数下的二进制最大值。</p>
</blockquote>
<p>获得 <code>table-&gt;nbBuckets</code> 之后，再初始化 <code>table-&gt;nbBuckets * sizeof (HashBucket)</code> 大小的内存空间。</p>
<h4 id="NXHashTablePrototype"><a href="#NXHashTablePrototype" class="headerlink" title="NXHashTablePrototype"></a>NXHashTablePrototype</h4><p>在继续分析其它方法之前，我们需要先知道 <code>NXHashTablePrototype</code> 是什么：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    uintptr_t (*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> (*isEqual)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data1, <span class="keyword">const</span> <span class="keyword">void</span> *data2);</span><br><span class="line">    <span class="keyword">void</span> (*free)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> style; <span class="comment">/* reserved for future expansion; currently 0 */</span></span><br><span class="line">&#125; NXHashTablePrototype;</span><br></pre></td></tr></table></figure>
<p><code>NXHashTablePrototype</code> 中存储了 <code>hash</code>、<code>isEqual</code> 和 <code>free</code> 的函数指针（用于获取数据的哈希、判断两个数据是否相等以及释放数据）。</p>
<p>在 <code>hashtable2.mm</code> 文件中有一个宏 <code>ISEQUAL</code> 就是用了 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 来判断两个数据是否相等：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISEQUAL(table, data1, data2) ((data1 == data2) || (*table-&gt;prototype-&gt;isEqual)(table-&gt;info, data1, data2))</span></span><br></pre></td></tr></table></figure>
<p>可以说，<code>NXHashTablePrototype</code> 中存储了一些<strong>构建哈希表必要的函数指针</strong>。</p>
<blockquote>
<p>因为 <code>NXHashTable</code> 使用<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" target="_blank" rel="noopener">拉链法</a>来实现哈希表，在存入表前对数据执行 hash，然后找到对应的 buckets，如果与 buckets 中的数据相同（使用 isEqual 判断），就替换原数据，否则将数据添加到链表中。</p>
</blockquote>
<h4 id="HashBucket"><a href="#HashBucket" class="headerlink" title="HashBucket"></a>HashBucket</h4><p>在这里另一个需要注意的数据结构就是 <code>HashBucket</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>	&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    oneOrMany elements;</span><br><span class="line">&#125; HashBucket;</span><br></pre></td></tr></table></figure>
<p><code>oneOrMany</code> 是一个 <code>union</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *one;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **many;</span><br><span class="line">&#125; oneOrMany;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这么设计的主要原因是<strong>提升性能</strong>。</p>
</blockquote>
<p>如果 <code>HashBucket</code> 中只有一个元素，那么就直接访问 <code>one</code>，否则访问 <code>many</code>，遍历这个 <code>many</code> 列表。</p>
<h3 id="NXCountHashTable"><a href="#NXCountHashTable" class="headerlink" title="NXCountHashTable"></a>NXCountHashTable</h3><p><code>NXCountHashTable</code> 方法应该是我们要介绍的方法中的最简单的一个，它会直接返回 <code>NXHashTable</code> 结构体中的 <code>count</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> NXCountHashTable (NXHashTable *table) &#123;</span><br><span class="line">    <span class="keyword">return</span> table-&gt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NXHashMember"><a href="#NXHashMember" class="headerlink" title="NXHashMember"></a>NXHashMember</h3><p><code>NXHashMember</code> 的函数签名虽然会返回 <code>int</code>，其实它是一个布尔值，会判断当前的 <code>NXHashTable</code> 中是否包含传入的数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NXHashMember (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket	*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>	j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one);</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>BUCKETOF</code> 对 <code>data</code> 进行 hash，将结果与哈希表的 <code>buckets</code> 数取模，返回 <code>buckets</code> 数组中对应的 <code>NXHashBucket</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define BUCKETOF(table, data) (((HashBucket *)table-&gt;buckets)+((*table-&gt;prototype-&gt;hash)(table-&gt;info, data) % table-&gt;nbBuckets))</span></span><br></pre></td></tr></table></figure>
<p>在获取了 <code>bucket</code> 之后，根据其中元素个数的不同，选择不同的分支：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one);</span><br><span class="line">&#125;;</span><br><span class="line">pairs = bucket-&gt;elements.many;</span><br><span class="line"><span class="keyword">while</span> (j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    pairs ++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>count == 0</code>，直接返回</li>
<li><code>count == 1</code>，使用 <code>ISEQUAL</code> 比较查找的数据与 <code>bucket-&gt;elements.one</code> </li>
<li><p><code>count &gt; 1</code>，依次与 <code>bucket-&gt;elements.many</code> 中的值进行比较</p>
<blockquote>
<p>你可能觉得到这里的时间复杂度比较糟糕，然而这个列表并不会很长，具体会在 <a href="#nxhashinsert">NXHashInsert</a> 中解释。</p>
</blockquote>
</li>
</ul>
<h3 id="NXHashGet"><a href="#NXHashGet" class="headerlink" title="NXHashGet"></a>NXHashGet</h3><blockquote>
<p>其实我一直觉得这个方法可能用处不是很大，尤其是在使用默认的 <code>NXHashTablePrototype</code> 时，因为默认的 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 函数指针只是比较两个数据的指针是否相同。</p>
<p>其最大作用就是查看当前 <code>data</code> 是不是在表中。</p>
<p>如果当前数据在表中，那么这个方法只会返回一个相同的指针，没有太多的意义。</p>
</blockquote>
<p>它的实现跟上面的 <code>NXHashMember</code> 区别并不大，这里就不过多介绍了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *NXHashGet (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket	*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>	j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one)</span><br><span class="line">        ? (<span class="keyword">void</span> *) bucket-&gt;elements.one : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> (<span class="keyword">void</span> *) *pairs;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NXHashInsert"><a href="#NXHashInsert" class="headerlink" title="NXHashInsert"></a>NXHashInsert</h3><p><code>NXHashInsert</code> 是 <code>NXHashTable</code> 中比较重要的方法，其作用就是向表中插入数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *NXHashInsert (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket *bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span> j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **pairs;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **newt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) &#123;</span><br><span class="line">        bucket-&gt;count++;</span><br><span class="line">        bucket-&gt;elements.one = data;</span><br><span class="line">        table-&gt;count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, bucket-&gt;elements.one)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span> *old = bucket-&gt;elements.one;</span><br><span class="line">            bucket-&gt;elements.one = data;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">        newt[<span class="number">1</span>] = bucket-&gt;elements.one;</span><br><span class="line">        *newt = data;</span><br><span class="line">        bucket-&gt;count++;</span><br><span class="line">        bucket-&gt;elements.many = newt;</span><br><span class="line">        table-&gt;count++;</span><br><span class="line">        <span class="keyword">if</span> (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>	*old = *pairs;</span><br><span class="line">            *pairs = data;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    newt = ALLOCPAIRS(z, bucket-&gt;count+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;count) bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)bucket-&gt;elements.many, (<span class="keyword">char</span>*)(newt+<span class="number">1</span>), bucket-&gt;count * PTRSIZE);</span><br><span class="line">    *newt = data;</span><br><span class="line">    FREEPAIRS (bucket-&gt;elements.many);</span><br><span class="line">    bucket-&gt;count++; </span><br><span class="line">    bucket-&gt;elements.many = newt;</span><br><span class="line">    table-&gt;count++;</span><br><span class="line">    <span class="keyword">if</span> (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这里的实现比上面的两个方法复杂得多，但是脉络仍然很清晰，我们将插入的过程分为三种情况：</p>
<ul>
<li><code>bucket-&gt;count == 0</code></li>
<li><code>bucket-&gt;count == 1</code></li>
<li><code>bucket-&gt;count &gt; 1</code></li>
</ul>
<p>如果对应的 <code>bucket</code> 为空：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! j) &#123;</span><br><span class="line">    bucket-&gt;count++; </span><br><span class="line">    bucket-&gt;elements.one = data;</span><br><span class="line">    table-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将数据直接填入 <code>bucket</code>，增加 <code>bucket</code> 中元素的数目，以及 <code>table</code> 中存储的元素的数目：</p>
<p><img src="../images/objc-hashtable-insert-empty.gif" alt="objc-hashtable-insert-empty"></p>
<p>如果原来的 <code>buckets</code> 中有一个元素，它会替换或者使用 <code>many</code> 替换原来的 <code>one</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, data, bucket-&gt;elements.one)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>	*old = bucket-&gt;elements.one;</span><br><span class="line">        bucket-&gt;elements.one = data;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">    newt[<span class="number">1</span>] = bucket-&gt;elements.one;</span><br><span class="line">    *newt = data;</span><br><span class="line">    bucket-&gt;count++;</span><br><span class="line">    bucket-&gt;elements.many = newt;</span><br><span class="line">    table-&gt;count++;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当前数据 <code>data</code> 如果与 <code>bucket</code> 中存储的数据相同，就会更新这个数据，否则就会使用 <code>ALLOCPAIRS</code> 初始化一个新的数组，然后将 <code>data</code> 和原来的数据传入。</p>
<p><img src="../images/objc-hashtable-insert-one.gif.gif" alt="objc-hashtable-insert-one.gif"></p>
<p>但是如果原来的 <code>bucket</code> 中存储的元素大于 1，那么会在链表的头部追加一个新的元素：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>	*old = *pairs;</span><br><span class="line">        *pairs = data;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs ++;</span><br><span class="line">&#125;;</span><br><span class="line">newt = ALLOCPAIRS(z, bucket-&gt;count+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (bucket-&gt;count) bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)bucket-&gt;elements.many, (<span class="keyword">char</span>*)(newt+<span class="number">1</span>), bucket-&gt;count * PTRSIZE);</span><br><span class="line">*newt = data;</span><br><span class="line">FREEPAIRS (bucket-&gt;elements.many);</span><br><span class="line">bucket-&gt;count++;</span><br><span class="line">bucket-&gt;elements.many = newt;</span><br><span class="line">table-&gt;count++;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用 <code>bcopy</code> 将原链表中元素拷贝到新的数组 <code>newt</code> 中。</p>
<p><img src="../images/objc-hashtable-insert-many.gif.gif" alt="objc-hashtable-insert-many.gif"></p>
<p>在每次添加完一个元素之后，都会进行下面的判断：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的这行代码会保证<strong>哈希表中的元素数据小于等于表中的 bucket 数量</strong>。</p>
</blockquote>
<p>这就是 <code>buckets</code> 后面的列表非常短的原因，在理想情况下，<strong>每一个 <code>buckets</code> 中都只存储一个或零个元素</strong>。</p>
<h4 id="NXHashRehash"><a href="#NXHashRehash" class="headerlink" title="_NXHashRehash"></a>_NXHashRehash</h4><p>如果哈希表在添加元素后，其中的数据多于 <code>buckets</code> 数量，就会对 <code>NXHashTable</code> 进行 <code>_NXHashRehash</code> 操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _NXHashRehash (NXHashTable *table) &#123;</span><br><span class="line">    _NXHashRehashToCapacity (table, MORE_CAPACITY(table-&gt;nbBuckets));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用 <code>_NXHashRehashToCapacity</code> 方法来扩大 <code>NXHashTable</code> 的容量（<code>HashBucket</code> 的个数）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MORE_CAPACITY(b) (b*2+1)</span></span><br></pre></td></tr></table></figure>
<p>而 <code>MORE_CAPACITY</code> 会将当前哈希表的容量翻倍，并将新的容量传入 <code>_NXHashRehashToCapacity</code> 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _NXHashRehashToCapacity (NXHashTable *table, <span class="keyword">unsigned</span> newCapacity) &#123;</span><br><span class="line">    NXHashTable	*old;</span><br><span class="line">    NXHashState	state;</span><br><span class="line">    <span class="keyword">void</span>	*aux;</span><br><span class="line">    __unused <span class="keyword">void</span> *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    old = ALLOCTABLE(z);</span><br><span class="line">    old-&gt;prototype = table-&gt;prototype; old-&gt;count = table-&gt;count;</span><br><span class="line">    old-&gt;nbBuckets = table-&gt;nbBuckets; old-&gt;buckets = table-&gt;buckets;</span><br><span class="line">    table-&gt;nbBuckets = newCapacity;</span><br><span class="line">    table-&gt;count = <span class="number">0</span>; table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);</span><br><span class="line">    state = NXInitHashState (old);</span><br><span class="line">    <span class="keyword">while</span> (NXNextHashState (old, &amp;state, &amp;aux))</span><br><span class="line">        (<span class="keyword">void</span>) NXHashInsert (table, aux);</span><br><span class="line">    freeBuckets (old, <span class="literal">NO</span>);</span><br><span class="line">    </span><br><span class="line">    free (old-&gt;buckets);</span><br><span class="line">    free (old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 <code>NXHashTable</code> 的指针指向原哈希表</li>
<li>改变哈希表的 <code>nbBuckets</code>，并重新初始化哈希表的 <code>buckets</code> 数组</li>
<li>重新将元素插入到哈希表中</li>
<li>释放原哈希表 <code>old</code> 以及 <code>buckets</code></li>
</ol>
<h4 id="NXHashState"><a href="#NXHashState" class="headerlink" title="NXHashState"></a>NXHashState</h4><p>在将元素重新插入到哈希表中涉及了一个非常奇怪的结构体 <code>NXHashState</code>，这个结构体主要作用是遍历 <code>NXHashTable</code> 中的元素。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125; NXHashState;</span><br></pre></td></tr></table></figure>
<p>我们可以使用如下的代码对哈希表中的元素进行遍历：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line">MyData	 *data;</span><br><span class="line">NXHashState state = NXInitHashState(table);</span><br><span class="line"><span class="keyword">while</span> (NXNextHashState(table, &amp;state, &amp;data)) &#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码片段中调用了两个方法，分别是 <code>NXInitHashState</code> 以及 <code>NXNextHashState</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NXHashState NXInitHashState (NXHashTable *table) &#123;</span><br><span class="line">    NXHashState	state;</span><br><span class="line"></span><br><span class="line">    state.i = table-&gt;nbBuckets;</span><br><span class="line">    state.j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NXInitHashState</code> 会将 <code>NXHashState</code> 指向哈希表的最末端：</p>
<p><img src="../images/objc-hashtable-hash-state-init.png" alt="objc-hashtable-hash-state-init"></p>
<blockquote>
<p>这个位置其实并不属于 <code>NXHashTable</code>，它一定会为空。</p>
</blockquote>
<p>而每次调用 <code>NXNextHashState</code> 都会向『前』移动一次：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NXNextHashState (NXHashTable *table, NXHashState *state, <span class="keyword">void</span> **data) &#123;</span><br><span class="line">    HashBucket		*buckets = (HashBucket *) table-&gt;buckets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (state-&gt;j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        state-&gt;i--; state-&gt;j = buckets[state-&gt;i].count;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;j--;</span><br><span class="line">    buckets += state-&gt;i;</span><br><span class="line">    *data = (<span class="keyword">void</span> *) ((buckets-&gt;count == <span class="number">1</span>)</span><br><span class="line">                      ? buckets-&gt;elements.one : buckets-&gt;elements.many[state-&gt;j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面的 gif 为我们展示了每一次调用 <code>NXNextHashState</code> 方法之后当前的 <code>NXHashState</code>：</p>
<p><img src="../images/objc-hashtable-hashstate-next.gif" alt="objc-hashtable-hashstate-next"></p>
<h3 id="NXHashRemove"><a href="#NXHashRemove" class="headerlink" title="NXHashRemove"></a>NXHashRemove</h3><p>这里的 <code>NXHashRemove</code>在某种意义上是 <code>NXHashInsert</code> 的逆操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *NXHashRemove (NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket	*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>	j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**pairs;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	**newt;</span><br><span class="line">    __unused <span class="keyword">void</span> *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! ISEQUAL(table, data, bucket-&gt;elements.one)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        data = bucket-&gt;elements.one;</span><br><span class="line">        table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.one = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) data;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, pairs[<span class="number">0</span>])) &#123;</span><br><span class="line">            bucket-&gt;elements.one = pairs[<span class="number">1</span>]; data = pairs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ISEQUAL(table, data, pairs[<span class="number">1</span>])) &#123;</span><br><span class="line">            bucket-&gt;elements.one = pairs[<span class="number">0</span>]; data = pairs[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        FREEPAIRS (pairs);</span><br><span class="line">        table-&gt;count--; bucket-&gt;count--;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *) data;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) &#123;</span><br><span class="line">            data = *pairs;</span><br><span class="line">            <span class="comment">/* we shrink this bucket */</span></span><br><span class="line">            newt = (bucket-&gt;count<span class="number">-1</span>)</span><br><span class="line">            ? ALLOCPAIRS(z, bucket-&gt;count<span class="number">-1</span>) : <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (bucket-&gt;count<span class="number">-1</span> != j)</span><br><span class="line">                bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)bucket-&gt;elements.many, (<span class="keyword">char</span>*)newt, PTRSIZE*(bucket-&gt;count-j<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                bcopy ((<span class="keyword">const</span> <span class="keyword">char</span>*)(bucket-&gt;elements.many + bucket-&gt;count-j), (<span class="keyword">char</span>*)(newt+bucket-&gt;count-j<span class="number">-1</span>), PTRSIZE*j);</span><br><span class="line">            FREEPAIRS (bucket-&gt;elements.many);</span><br><span class="line">            table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.many = newt;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *) data;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的实现也分为三种情况，不过在这里就不多说了。</p>
<h2 id="NXHashTable-的性能"><a href="#NXHashTable-的性能" class="headerlink" title="NXHashTable 的性能"></a>NXHashTable 的性能</h2><p>在已经熟悉了 <code>NXHashTable</code> 的具体实现之后，我们要分析插入<strong>不同数据量级</strong>的情况下，所需要的时间，这里是主程序的代码，分别测试了在 <code>100, 1000, 10000, 100000, 1000000, 2000000, 3000000, 5000000, 10000000</code> 数据下 <code>NXHashTable</code> 的性能表现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"hashtable2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *capacities = @[</span><br><span class="line">            @<span class="number">100</span>,</span><br><span class="line">            @<span class="number">1000</span>,</span><br><span class="line">            @<span class="number">10000</span>,</span><br><span class="line">            @<span class="number">100000</span>,</span><br><span class="line">            @<span class="number">1000000</span>,</span><br><span class="line">            @<span class="number">2000000</span>,</span><br><span class="line">            @<span class="number">3000000</span>,</span><br><span class="line">            @<span class="number">5000000</span>,</span><br><span class="line">            @<span class="number">10000000</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *capacity <span class="keyword">in</span> capacities) &#123;</span><br><span class="line">            NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">NSDate</span> *methodStart = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; capacity.integerValue; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, (<span class="keyword">long</span>)i];</span><br><span class="line">                NXHashInsert(hashTable, (__bridge <span class="keyword">void</span> *)value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSDate</span> *methodFinish = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="built_in">NSTimeInterval</span> executionTime = [methodFinish timeIntervalSinceDate:methodStart];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Capacities: %@, executionTime = %f, meanTime = %.10f"</span>, capacity, executionTime, executionTime / capacity.integerValue);</span><br><span class="line"></span><br><span class="line">            free(hashTable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中初始化了一个 <code>capacities</code> 存储需要测量的数据量级，然后调用 <code>NXHashInsert</code> 方法将相当数量级的数据添加到哈希表中：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000334</td>
<td style="text-align:right">0.0000033402</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.001962</td>
<td style="text-align:right">0.0000019619</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.022001</td>
<td style="text-align:right">0.0000022001</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.349998</td>
<td style="text-align:right">0.0000035000</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">2.622551</td>
<td style="text-align:right">0.0000026226</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">4.165023</td>
<td style="text-align:right">0.0000020825</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">6.973098</td>
<td style="text-align:right">0.0000023244</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">13.179743</td>
<td style="text-align:right">0.0000026359</td>
</tr>
<tr>
<td style="text-align:right"><strong>10000000</strong></td>
<td style="text-align:right"><strong>53.387356</strong></td>
<td style="text-align:right"><strong>0.0000053387</strong></td>
</tr>
</tbody>
</table>
<p>在对 <code>NXHashTable</code> 的性能测试中，当数据量小于 5000000 时，执行时间的增长还是线性的，平均时间也基本稳定，但是一旦数据量达到了千万级，执行时间就会出现显著的增长。</p>
<p>如果仅仅在哈希表中插入数据，相信其时间增长应该都是线性的，这里出现问题的原因推测是<strong>在对哈希表进行 Rehash 的时候，迁移原数据至新的数组所造成的</strong>。</p>
<p>如何避免哈希表的 Rehash 呢，重新回顾一下创建哈希表的函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTable (NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br></pre></td></tr></table></figure>
<p>这个函数的签名中包含一个 <code>capacity</code> 的参数，我们在上面的代码中传入了 0，也就是最开始的 <code>buckets</code> 数为 0，但是它的数目并不是固定的，它会随着哈希表中数据的增多，逐渐变大。</p>
<blockquote>
<p><code>capacity</code> 只是一个提示，帮助 NXHashTable 了解其中会存储多少数据。</p>
</blockquote>
<p>如果在创建 <code>NXHashTable</code> 时传入 <code>capacity.integerValue</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, capacity.integerValue, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>重新运行代码，测量性能：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000740</td>
<td style="text-align:right">0.0000073999</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.003442</td>
<td style="text-align:right">0.0000034420</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.023341</td>
<td style="text-align:right">0.0000023341</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.215209</td>
<td style="text-align:right">0.0000021521</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">1.836802</td>
<td style="text-align:right">0.0000018368</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">3.683246</td>
<td style="text-align:right">0.0000018416</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">5.474610</td>
<td style="text-align:right">0.0000018249</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">10.576254</td>
<td style="text-align:right">0.0000021153</td>
</tr>
<tr>
<td style="text-align:right">10000000</td>
<td style="text-align:right">46.725459</td>
<td style="text-align:right">0.0000046725</td>
</tr>
</tbody>
</table>
<p>虽然在测试 <code>10,000,000</code> 数据时其平均时间依然是 <code>5,000,000</code> 时的二倍，不过整体的性能都有所提升，然而这部分性能的损耗暂时还不是很清楚原因。</p>
<p>如果我们使用 Instrument 对有无 <code>capacity</code> 的情况进行比较（这是在使用 <code>2,000,000</code> 数据时进行的测试）：</p>
<p><img src="../images/objc-hashtable-instrument.png" alt="objc-hashtable-instrument"></p>
<p>没有传入 <code>capacity</code> 的哈希表会在多次插入之后出现一个峰值（由于 Rehash 引起的，其宽度就是 Rehash 使用的时间），而传入 <code>capacity</code> 的哈希表会在代码刚运行时就初始化足够大的数组。</p>
<h2 id="NSMutableArray-性能"><a href="#NSMutableArray-性能" class="headerlink" title="NSMutableArray 性能"></a>NSMutableArray 性能</h2><blockquote>
<p>这部分只算是一个小插曲，你可以选择跳过这一小节的内容。</p>
</blockquote>
<p><code>NSMutableArray</code> 的构造器 <code>- (instancetype)initWithCapacity:(NSUInteger)numItems</code> 也有一个参数 <code>capacity</code>，虽然数组和哈希表是两种数据结构。</p>
<blockquote>
<p>不过我们这里主要研究的是：<strong>传入 <code>capacity</code> 是否会对性能造成影响</strong>。</p>
</blockquote>
<p>首先是使用 <code>init</code> 创建的 <code>NSMutableArray</code> 数组，也就是没有传入 <code>capacity</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000539</td>
<td style="text-align:right">0.0000053900</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.003185</td>
<td style="text-align:right">0.0000031850</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.074033</td>
<td style="text-align:right">0.0000074033</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.370899</td>
<td style="text-align:right">0.0000037090</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">1.504855</td>
<td style="text-align:right">0.0000015049</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">2.852519</td>
<td style="text-align:right">0.0000014263</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">3.995536</td>
<td style="text-align:right">0.0000013318</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">6.833879</td>
<td style="text-align:right">0.0000013668</td>
</tr>
<tr>
<td style="text-align:right">10000000</td>
<td style="text-align:right">14.444605</td>
<td style="text-align:right">0.0000014445</td>
</tr>
</tbody>
</table>
<p>下面是使用 <code>initWithCapacity:</code> 创建的数组：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Capacities</th>
<th style="text-align:right">Execution Time</th>
<th style="text-align:right">Mean Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">100</td>
<td style="text-align:right">0.000256</td>
<td style="text-align:right">0.0000025600</td>
</tr>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">0.001775</td>
<td style="text-align:right">0.0000017750</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">0.015906</td>
<td style="text-align:right">0.0000015906</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">0.174376</td>
<td style="text-align:right">0.0000017438</td>
</tr>
<tr>
<td style="text-align:right">1000000</td>
<td style="text-align:right">1.650481</td>
<td style="text-align:right">0.0000016505</td>
</tr>
<tr>
<td style="text-align:right">2000000</td>
<td style="text-align:right">2.802310</td>
<td style="text-align:right">0.0000014012</td>
</tr>
<tr>
<td style="text-align:right">3000000</td>
<td style="text-align:right">4.451261</td>
<td style="text-align:right">0.0000014838</td>
</tr>
<tr>
<td style="text-align:right">5000000</td>
<td style="text-align:right">7.093753</td>
<td style="text-align:right">0.0000014188</td>
</tr>
<tr>
<td style="text-align:right">10000000</td>
<td style="text-align:right">14.598415</td>
<td style="text-align:right">0.0000014598</td>
</tr>
</tbody>
</table>
<p>你可以在表格中看到，两者在执行效率上并没有显著的差异或者区别。</p>
<p>但是如果使用 instrument 来查看两者的内存分配，可以很明显的看到，没有传入 <code>capacity</code> 的 <code>NSMutableArray</code> 会在可变数组内存占用增加前出现一个<strong>短暂的内存分配峰值</strong>。</p>
<p><img src="../images/objc-hashtable-nsarray-instrument.png" alt="objc-hashtable-nsarray-instrument"></p>
<p>导致这一现象的原始可能是：在将原数组中的内容移入新数组时，<strong>临时变量申请了大量的内存空间</strong>。</p>
<blockquote>
<p>在之后关于 CoreFoundation 源代码分析的文中会介绍它们是怎么实现的。</p>
</blockquote>
<h2 id="NXHashTable-的应用"><a href="#NXHashTable-的应用" class="headerlink" title="NXHashTable 的应用"></a>NXHashTable 的应用</h2><p>在整个 objc/runtime 中，作为<strong>私有</strong>的数据结构 <code>NXHashTable</code>，直接使用了它的就是<strong>存储所有类或者元类</strong>的哈希表（在这里会忽略对元类的存储，因为实现几乎完全相同）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NXHashTable *realized_class_hash = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>objc_copyClassList</code> 获取类的数组：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class *</span><br><span class="line">objc_copyClassList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    realizeAllClasses();</span><br><span class="line"></span><br><span class="line">    Class *result = <span class="literal">nil</span>;</span><br><span class="line">    NXHashTable *classes = realizedClasses();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = NXCountHashTable(classes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        NXHashState state = NXInitHashState(classes);</span><br><span class="line">        result = (Class *)malloc((<span class="number">1</span>+count) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (NXNextHashState(classes, &amp;state, (<span class="keyword">void</span> **)&amp;cls)) &#123;</span><br><span class="line">            result[count++] = cls;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = count;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <code>realizedClasses</code> 返回 <code>realized_class_hash</code> 哈希表</li>
<li>使用 <code>NSHashState</code> 遍历 <code>realized_class_hash</code> 中的类，并将所有的类存入 <code>result</code></li>
</ol>
<p>接下来使用上面的方法，打印出 <code>realized_class_hash</code> 中存储的所有类：</p>
<p><img src="../images/objc-hashtable-copy-class-list.png" alt="objc-hashtable-copy-class-list"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p><code>NXHashTable</code> 在 OS X 10.1 中就已经标记为弃用了，但是依旧支持着 runtime 底层的工作。</p>
</blockquote>
<p><code>NXHashTable</code> 可以说有着<strong>非常非常</strong>久远的历史了，最早可以追溯到将近 30 多年前 NeXT 时代：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashtable2.mm 文件中</span></span><br><span class="line"></span><br><span class="line">hashtable2.m</span><br><span class="line">Copyright <span class="number">1989</span><span class="number">-1996</span> NeXT Software, Inc.</span><br><span class="line">Created by Bertrand Serlet, Feb <span class="number">89</span></span><br></pre></td></tr></table></figure>
<p><code>NSHashTable</code> 对哈希表的实现还是非常优雅的，可以说非常标准的使用了<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" target="_blank" rel="noopener">拉链法</a>实现哈希表。</p>
<p>不过现在，我们会使用 <code>NSHashTable</code> 来取代这个上古时代的产物。</p>
<blockquote>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">Draveness · Github</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/" data-id="cjw6zovu90002bn043i7r3wml" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-objc/从源代码看 ObjC 中消息的发送" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/从源代码看 ObjC 中消息的发送/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="从源代码看-ObjC-中消息的发送"><a href="#从源代码看-ObjC-中消息的发送" class="headerlink" title="从源代码看 ObjC 中消息的发送"></a>从源代码看 ObjC 中消息的发送</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：</p>
<ol>
<li>在 Objective-C 中的“方法调用”其实应该叫做消息传递</li>
<li><code>[receiver message]</code> 会被翻译为 <code>objc_msgSend(receiver, @selector(message))</code></li>
<li>在消息的响应链中<strong>可能</strong>会调用 <code>- resolveInstanceMethod:</code> <code>- forwardInvocation:</code> 等方法</li>
<li><p>关于选择子 SEL 的知识</p>
<blockquote>
<p>如果对于上述的知识不够了解，可以看一下这篇文章 <a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a>，但是其中关于 <code>objc_class</code> 的结构体的代码已经过时了，不过不影响阅读以及理解。</p>
</blockquote>
</li>
<li><p>方法在内存中存储的位置，<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a>（可选）</p>
<blockquote>
<p>文章中不会刻意区别方法和函数、消息传递和方法调用之间的区别。</p>
</blockquote>
</li>
<li><p>能翻墙（会有一个 Youtube 的链接）</p>
</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>关于 Objective-C 中的消息传递的文章真的是太多了，而这篇文章又与其它文章有什么不同呢？</p>
<p>由于这个系列的文章都是对 Objective-C 源代码的分析，所以会<strong>从 Objective-C 源代码中分析并合理地推测一些关于消息传递的问题</strong>。</p>
<p><img src="../images/objc-message-core.png" alt="objc-message-core"></p>
<h2 id="关于-selector-你需要知道的"><a href="#关于-selector-你需要知道的" class="headerlink" title="关于 @selector() 你需要知道的"></a>关于 @selector() 你需要知道的</h2><p>因为在 Objective-C 中，所有的消息传递中的“消息“都会被转换成一个 <code>selector</code> 作为 <code>objc_msgSend</code> 函数的参数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object hello] -&gt; objc_msgSend(object, <span class="keyword">@selector</span>(hello))</span><br></pre></td></tr></table></figure>
<p>这里面使用 <code>@selector(hello)</code> 生成的选择子 <strong>SEL</strong> 是这一节中关注的重点。</p>
<p>我们需要预先解决的问题是：使用 <code>@selector(hello)</code> 生成的选择子，是否会因为类的不同而不同？各位读者可以自己思考一下。</p>
<p>先放出结论：使用 <code>@selector()</code> 生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了。也就是说<strong>向不同的类发送相同的消息时，其生成的选择子是完全相同的</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XXObject *xx = [[XXObject alloc] init]</span><br><span class="line">YYObject *yy = [[YYObject alloc] init]</span><br><span class="line">objc_msgSend(xx, <span class="keyword">@selector</span>(hello))</span><br><span class="line">objc_msgSend(yy, <span class="keyword">@selector</span>(hello))</span><br></pre></td></tr></table></figure>
<p>接下来，我们开始验证这一结论的正确性，这是程序主要包含的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数任意位置打一个断点， 比如 <code>-&gt; [object hello];</code> 这里，然后在 lldb 中输入：</p>
<p><img src="../images/objc-message-selector.png" alt="objc-message-selecto"></p>
<p>这里面我们打印了两个选择子的地址<code>@selector(hello)</code> 以及 <code>@selector(undefined_hello_method)</code>，需要注意的是：</p>
<blockquote>
<p><code>@selector(hello)</code> 是在编译期间就声明的选择子，而后者在编译期间并不存在，<code>undefined_hello_method</code> 选择子由于是在运行时生成的，所以内存地址明显比 <code>hello</code> 大很多</p>
</blockquote>
<p>如果我们修改程序的代码：</p>
<p><img src="../images/objc-message-selector-undefined.png" alt="objc-message-selector-undefined"></p>
<p>在这里，由于我们在代码中显示地写出了 <code>@selector(undefined_hello_method)</code>，所以在 lldb 中再次打印这个 <code>sel</code> 内存地址跟之前相比有了很大的改变。</p>
<p>更重要的是，我没有通过指针的操作来获取 <code>hello</code> 选择子的内存地址，而只是通过 <code>@selector(hello)</code> 就可以返回一个选择子。</p>
<p>从上面的这些现象，可以推断出选择子有以下的特性：</p>
<ol>
<li>Objective-C 为我们维护了一个巨大的选择子表</li>
<li>在使用 <code>@selector()</code> 时会从这个选择子表中根据选择子的名字查找对应的 <code>SEL</code>。如果没有找到，则会生成一个 <code>SEL</code> 并添加到表中</li>
<li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 <code>@selector()</code> 生成的选择子加入到选择子表中</li>
</ol>
<p>在运行时初始化之前，打印 <code>hello</code> 选择子的的内存地址：</p>
<p><img src="../images/objc-message-find-selector-before-init.png" alt="objc-message-find-selector-before-init"></p>
<h2 id="message-h-文件"><a href="#message-h-文件" class="headerlink" title="message.h 文件"></a>message.h 文件</h2><p>Objective-C 中 <code>objc_msgSend</code> 的实现并没有开源，它只存在于 <code>message.h</code> 这个头文件中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @note When it encounters a method call, the compiler generates a call to one of the</span></span><br><span class="line"><span class="comment"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</span></span><br><span class="line"><span class="comment"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;</span></span><br><span class="line"><span class="comment"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</span></span><br><span class="line"><span class="comment"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>在这个头文件的注释中对<strong>消息发送的一系列方法</strong>解释得非常清楚：</p>
<blockquote>
<p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 <code>objc_msgSend</code>、<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code> 和 <code>objc_msgSendSuper_stret</code>。<br>发送给对象的父类的消息会使用 <code>objc_msgSendSuper</code><br>有数据结构作为返回值的方法会使用 <code>objc_msgSendSuper_stret</code> 或 <code>objc_msgSend_stret</code><br>其它的消息都是使用 <code>objc_msgSend</code> 发送的</p>
</blockquote>
<p>在这篇文章中，我们只会对<strong>消息发送的过程</strong>进行分析，而不会对<strong>上述消息发送方法的区别</strong>进行分析，默认都使用 <code>objc_msgSend</code> 函数。</p>
<h2 id="objc-msgSend-调用栈"><a href="#objc-msgSend-调用栈" class="headerlink" title="objc_msgSend 调用栈"></a>objc_msgSend 调用栈</h2><p>这一小节会以向 <code>XXObject</code> 的实例发送 <code>hello</code> 消息为例，在 Xcode 中观察整个消息发送的过程中调用栈的变化，再来看一下程序的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>hello</code> 方法的这一行打一个断点，当我们尝试进入（Step in）这个方法只会直接跳入这个方法的实现，而不会进入 <code>objc_msgSend</code>：</p>
<p><img src="../images/objc-message-wrong-step-in.gif" alt="objc-message-wrong-step-in"></p>
<p>因为 <code>objc_msgSend</code> 是一个私有方法，我们没有办法进入它的实现，但是，我们却可以在 <code>objc_msgSend</code> 的调用栈中“截下”这个函数调用的过程。</p>
<p>调用 <code>objc_msgSend</code> 时，传入了 <code>self</code> 以及 <code>SEL</code> 参数。</p>
<p>既然要执行对应的方法，肯定要寻找选择子对应的实现。</p>
<p>在 <code>objc-runtime-new.mm</code> 文件中有一个函数 <code>lookUpImpOrForward</code>，这个函数的作用就是查找方法的实现，于是运行程序，在运行到 <code>hello</code> 这一行时，激活 <code>lookUpImpOrForward</code> 函数中的断点。</p>
<p><a href="https://youtu.be/bCdjdI4VhwQ" target="_blank"><img src="../images/objc-message-youtube-preview.jpg"></a></p>
<blockquote>
<p>由于转成 gif 实在是太大了，笔者试着用各种方法生成动图，然而效果也不是很理想，只能贴一个 Youtube 的视频链接，不过对于能够翻墙的开发者们，应该也不是什么问题吧（手动微笑）</p>
</blockquote>
<p>如果跟着视频看这个方法的调用栈有些混乱的话，也是正常的。在下一个节中会对其调用栈进行详细的分析。</p>
<h1 id="解析-objc-msgSend"><a href="#解析-objc-msgSend" class="headerlink" title="解析 objc_msgSend"></a>解析 objc_msgSend</h1><p>对 <code>objc_msgSend</code> 解析总共分两个步骤，我们会向 <code>XXObject</code> 的实例发送两次 <code>hello</code> 消息，分别模拟无缓存和有缓存两种情况下的调用栈。</p>
<h2 id="无缓存"><a href="#无缓存" class="headerlink" title="无缓存"></a>无缓存</h2><p>在 <code>-&gt; [object hello]</code> 这里增加一个断点，<strong>当程序运行到这一行时</strong>，再向 <code>lookUpImpOrForward</code> 函数的第一行添加断点，确保是捕获 <code>@selector(hello)</code> 的调用栈，而不是调用其它选择子的调用栈。</p>
<p><img src="../images/objc-message-first-call-hello.png" alt="objc-message-first-call-hello"></p>
<p>由图中的变量区域可以了解，传入的选择子为 <code>&quot;hello&quot;</code>，对应的类是 <code>XXObject</code>。所以我们可以确信这就是当调用 <code>hello</code> 方法时执行的函数。在 Xcode 左侧能看到方法的调用栈：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> lookUpImpOrForward</span><br><span class="line"><span class="number">1</span> _class_lookupMethodAndLoadCache3</span><br><span class="line"><span class="number">2</span> objc_msgSend</span><br><span class="line"><span class="number">3</span> main</span><br><span class="line"><span class="number">4</span> start</span><br></pre></td></tr></table></figure>
<p>调用栈在这里告诉我们： <code>lookUpImpOrForward</code> 并不是 <code>objc_msgSend</code> 直接调用的，而是通过 <code>_class_lookupMethodAndLoadCache3</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(<span class="keyword">id</span> obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj,</span><br><span class="line">                              <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">NO</span><span class="comment">/*cache*/</span>, <span class="literal">YES</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个<strong>仅提供给派发器（dispatcher）</strong>用于方法查找的函数，其它的代码都应该使用 <code>lookUpImpOrNil()</code>（不会进行方法转发）。<code>_class_lookupMethodAndLoadCache3</code> 会传入 <code>cache = NO</code> 避免在<strong>没有加锁</strong>的时候对缓存进行查找，因为派发器已经做过这件事情了。</p>
<h3 id="实现的查找-lookUpImpOrForward"><a href="#实现的查找-lookUpImpOrForward" class="headerlink" title="实现的查找 lookUpImpOrForward"></a>实现的查找 lookUpImpOrForward</h3><p>由于实现的查找方法 <code>lookUpImpOrForward</code> 涉及很多函数的调用，所以我们将它分成以下几个部分来分析：</p>
<ol>
<li>无锁的缓存查找</li>
<li>如果类没有实现（isRealized）或者初始化（isInitialized），实现或者初始化类</li>
<li>加锁</li>
<li>缓存以及当前类中方法的查找</li>
<li>尝试查找父类的缓存以及方法列表</li>
<li>没有找到实现，尝试方法解析器</li>
<li>进行消息转发</li>
<li>解锁、返回实现</li>
</ol>
<h4 id="无锁的缓存查找"><a href="#无锁的缓存查找" class="headerlink" title="无锁的缓存查找"></a>无锁的缓存查找</h4><p>下面是在没有加锁的时候对缓存进行查找，提高缓存使用的性能：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optimistic cache lookup</span></span><br><span class="line"><span class="keyword">if</span> (cache) &#123;</span><br><span class="line">   imp = cache_getImp(cls, sel);</span><br><span class="line">   <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过因为 <code>_class_lookupMethodAndLoadCache3</code> 传入的 <code>cache = NO</code>，所以这里会直接跳过 if 中代码的执行，在 <code>objc_msgSend</code> 中已经使用汇编代码查找过了。</p>
<h4 id="类的实现和初始化"><a href="#类的实现和初始化" class="headerlink" title="类的实现和初始化"></a>类的实现和初始化</h4><p>在 <em>Objective-C 运行时</em> 初始化的过程中会对其中的类进行第一次初始化也就是执行 <code>realizeClass</code> 方法，为类分配可读写结构体 <code>class_rw_t</code> 的空间，并返回正确的类结构体。</p>
<p>而 <code>_class_initialize</code> 方法会调用类的 <code>initialize</code> 方法，我会在之后的文章中对类的初始化进行分析。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line">    realizeClass(cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>加锁这一部分只有一行简单的代码，其主要目的保证方法查找以及缓存填充（cache-fill）的原子性，保证在运行以下代码时不会有<strong>新方法添加导致缓存被冲洗（flush）</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.read();</span><br></pre></td></tr></table></figure>
<h4 id="在当前类中查找实现"><a href="#在当前类中查找实现" class="headerlink" title="在当前类中查找实现"></a>在当前类中查找实现</h4><p>实现很简单，先调用了 <code>cache_getImp</code> 从某个类的 <code>cache</code> 属性中获取选择子对应的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imp = cache_getImp(cls, sel);</span><br><span class="line"><span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-message-cache-struct.png" alt="objc-message-cache-struct"></p>
<p>不过 <code>cache_getImp</code> 的实现目测是不开源的，同时也是汇编写的，在我们尝试 step in 的时候进入了如下的汇编代码。</p>
<p><img src="../images/objc-message-step-in-cache-getimp.png" alt="objc-message-step-in-cache-getimp"></p>
<p>它会进入一个 <code>CacheLookup</code> 的标签，获取实现，使用汇编的原因还是因为要加速整个实现查找的过程，其原理推测是在类的 <code>cache</code> 中寻找对应的实现，只是做了一些性能上的优化。</p>
<p>如果查找到实现，就会跳转到 <code>done</code> 标签，因为我们在这个小结中的假设是无缓存的（第一次调用 <code>hello</code> 方法），所以会进入下面的代码块，从类的方法列表中寻找方法的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line"><span class="keyword">if</span> (meth) &#123;</span><br><span class="line">    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">    imp = meth-&gt;imp;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>getMethodNoSuper_nolock</code> 方法查找对应的方法的结构体指针 <code>method_t</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *getMethodNoSuper_nolock(Class cls, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),</span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists();</span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        method_t *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类中数据的方法列表 <code>methods</code> 是一个二维数组 <code>method_array_t</code>，写一个 <code>for</code> 循环遍历整个方法列表，而这个 <code>search_method_list</code> 的实现也特别简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *search_method_list(<span class="keyword">const</span> method_list_t *mlist, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="keyword">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(method_t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findMethodInSortedMethodList</code> 方法对有序方法列表进行线性探测，返回方法结构体 <code>method_t</code>。</p>
<p>如果在这里找到了方法的实现，将它加入类的缓存中，这个操作最后是由 <code>cache_fill_nolock</code> 方法来完成的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> cache_fill_nolock(Class cls, SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line">    cache_key_t key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    mask_t newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    mask_t capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket_t *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果缓存中的内容大于容量的 <code>3/4</code> 就会扩充缓存，使缓存的大小翻倍。</p>
<blockquote>
<p>在缓存翻倍的过程中，当前类<strong>全部的缓存都会被清空</strong>，Objective-C 出于性能的考虑不会将原有缓存的 <code>bucket_t</code> 拷贝到新初始化的内存中。</p>
</blockquote>
<p>找到第一个空的 <code>bucket_t</code>，以 <code>(SEL, IMP)</code> 的形式填充进去。</p>
<h4 id="在父类中寻找实现"><a href="#在父类中寻找实现" class="headerlink" title="在父类中寻找实现"></a>在父类中寻找实现</h4><p>这一部分与上面的实现基本上是一样的，只是多了一个循环用来判断根类：</p>
<ol>
<li>查找缓存</li>
<li>搜索方法列表</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curClass = cls;</span><br><span class="line"><span class="keyword">while</span> ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">    imp = cache_getImp(curClass, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">            log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与当前类寻找实现的区别是：在父类中寻找到的 <code>_objc_msgForward_impcache</code> 实现会交给当前类来处理。</p>
<h4 id="方法决议"><a href="#方法决议" class="headerlink" title="方法决议"></a>方法决议</h4><p>选择子在当前类和父类中都没有找到实现，就进入了方法决议（method resolve）的过程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    _class_resolveMethod(cls, sel, inst);</span><br><span class="line">    triedResolver = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码调用 <code>_class_resolveMethod</code> 来解析没有找到实现的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, <span class="keyword">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst,</span><br><span class="line">                            <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据当前的类是不是<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">元类</a>在 <code>_class_resolveInstanceMethod</code> 和 <code>_class_resolveClassMethod</code> 中选择一个进行调用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, <span class="keyword">id</span> inst) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls,</span><br><span class="line">                         <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) &#123;</span><br><span class="line">        <span class="comment">// 没有找到 resolveInstanceMethod: 方法，直接返回。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (__typeof__(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存结果，以防止下次在调用 resolveInstanceMethod: 方法影响性能。</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst,</span><br><span class="line">                             <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法的实现其实就是判断当前类是否实现了 <code>resolveInstanceMethod:</code> 或者 <code>resolveClassMethod:</code> 方法，然后用 <code>objc_msgSend</code> 执行上述方法，并传入需要决议的选择子。</p>
<blockquote>
<p>关于 <code>resolveInstanceMethod</code> 之后可能会写一篇文章专门介绍，不过关于这个方法的文章也确实不少，在 Google 上搜索会有很多的文章。</p>
</blockquote>
<p>在执行了 <code>resolveInstanceMethod:</code> 之后，会跳转到 retry 标签，<strong>重新执行查找方法实现的流程</strong>，只不过不会再调用 <code>resolveInstanceMethod:</code> 方法了（将 <code>triedResolver</code> 标记为 <code>YES</code>）。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>在缓存、当前类、父类以及 <code>resolveInstanceMethod:</code> 都没有解决实现查找的问题时，Objective-C 还为我们提供了最后一次翻身的机会，进行方法转发：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure>
<p>返回实现 <code>_objc_msgForward_impcache</code>，然后加入缓存。</p>
<p>====</p>
<p>这样就结束了整个方法第一次的调用过程，缓存没有命中，但是在当前类的方法列表中找到了 <code>hello</code> 方法的实现，调用了该方法。</p>
<p><img src="../images/objc-message-first-call-hello.png" alt="objc-message-first-call-hello"></p>
<h2 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h2><p>如果使用对应的选择子时，缓存命中了，那么情况就大不相同了，我们修改主程序中的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在第二次调用 <code>hello</code> 方法时，加一个断点：</p>
<p><img src="../images/objc-message-objc-msgSend-with-cache.gif" alt="objc-message-objc-msgSend-with-cache"></p>
<p><code>objc_msgSend</code> 并没有走 <code>lookupImpOrForward</code> 这个方法，而是直接结束，打印了另一个 <code>hello</code> 字符串。</p>
<p>我们如何确定 <code>objc_msgSend</code> 的实现到底是什么呢？其实我们没有办法来<strong>确认</strong>它的实现，因为这个函数的实现使用汇编写的，并且实现是不开源的。</p>
<p>不过，我们需要确定它是否真的<strong>访问了类中的缓存</strong>来加速实现寻找的过程。</p>
<p>好，现在重新运行程序至第二个 <code>hello</code> 方法调用之前：</p>
<p><img src="../images/objc-message-before-flush-cache.png" alt="objc-message-before-flush-cache"></p>
<p>打印缓存中 bucket 的内容：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)[XXObject <span class="keyword">class</span>]</span><br><span class="line">(objc_class *) $<span class="number">0</span> = <span class="number">0x0000000100001230</span></span><br><span class="line">(lldb) p (cache_t *)<span class="number">0x0000000100001240</span></span><br><span class="line">(cache_t *) $<span class="number">1</span> = <span class="number">0x0000000100001240</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(cache_t) $<span class="number">2</span> = &#123;</span><br><span class="line">  _buckets = <span class="number">0x0000000100604bd0</span></span><br><span class="line">  _mask = <span class="number">3</span></span><br><span class="line">  _occupied = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>capacity()</span><br><span class="line">(mask_t) $<span class="number">3</span> = <span class="number">4</span></span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">0</span>]</span><br><span class="line">(bucket_t) $<span class="number">4</span> = &#123;</span><br><span class="line">  _key = <span class="number">0</span></span><br><span class="line">  _imp = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">1</span>]</span><br><span class="line">(bucket_t) $<span class="number">5</span> = &#123;</span><br><span class="line">  _key = <span class="number">0</span></span><br><span class="line">  _imp = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">2</span>]</span><br><span class="line">(bucket_t) $<span class="number">6</span> = &#123;</span><br><span class="line">  _key = <span class="number">4294971294</span></span><br><span class="line">  _imp = <span class="number">0x0000000100000e60</span> (debug-objc`-[XXObject hello] at XXObject.m:<span class="number">17</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">2.</span>buckets()[<span class="number">3</span>]</span><br><span class="line">(bucket_t) $<span class="number">7</span> = &#123;</span><br><span class="line">  _key = <span class="number">4300169955</span></span><br><span class="line">  _imp = <span class="number">0x00000001000622e0</span> (libobjc.A.dylib`-[<span class="built_in">NSObject</span> init] at <span class="built_in">NSObject</span>.mm:<span class="number">2216</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个缓存中只有对 <code>hello</code> 和 <code>init</code> 方法实现的缓存，我们要将其中 <code>hello</code> 的缓存清空：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr $<span class="number">2.</span>buckets()[<span class="number">2</span>] = $<span class="number">2.</span>buckets()[<span class="number">1</span>]</span><br><span class="line">(bucket_t) $<span class="number">8</span> = &#123;</span><br><span class="line">  _key = <span class="number">0</span></span><br><span class="line">  _imp = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-message-after-flush-cache.png" alt="objc-message-after-flush-cache"></p>
<p>这样 <code>XXObject</code> 中就不存在 <code>hello</code> 方法对应实现的缓存了。然后继续运行程序：</p>
<p><img src="../images/objc-message-after-flush-cache-trap-in-lookup-again.png" alt="objc-message-after-flush-cache-trap-in-lookup-again"></p>
<p>虽然第二次调用 <code>hello</code> 方法，但是因为我们清除了 <code>hello</code> 的缓存，所以，会再次进入 <code>lookupImpOrForward</code> 方法。</p>
<p>下面会换一种方法验证猜测：<strong>在 hello 调用之前添加缓存</strong>。</p>
<p>添加一个新的实现 <code>cached_imp</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __unused IMP cached_imp = imp_implementationWithBlock(^() &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Cached Hello"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        XXObject *object = [[XXObject alloc] init];</span><br><span class="line">        [object hello];</span><br><span class="line">        [object hello];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将以 <code>@selector(hello), cached_imp</code> 为键值对，将其添加到类结构体的缓存中，这里的实现 <code>cached_imp</code> 有一些区别，它会打印 <code>@&quot;Cached Hello&quot;</code> 而不是 <code>@&quot;Hello&quot;</code> 字符串：</p>
<p>在第一个 <code>hello</code> 方法调用之前将实现加入缓存：</p>
<p><img src="../images/objc-message-add-imp-to-cache.png" alt="objc-message-add-imp-to-cache"></p>
<p>然后继续运行代码：</p>
<p><img src="../images/objc-message-run-after-add-cache.png" alt="objc-message-run-after-add-cache"></p>
<p>可以看到，我们虽然没有改变 <code>hello</code> 方法的实现，但是在 <strong>objc_msgSend</strong> 的消息发送链路中，使用错误的缓存实现 <code>cached_imp</code> 拦截了实现的查找，打印出了 <code>Cached Hello</code>。</p>
<p>由此可以推定，<code>objc_msgSend</code> 在实现中确实检查了缓存。如果没有缓存会调用 <code>lookupImpOrForward</code> 进行方法查找。</p>
<p>为了提高消息传递的效率，ObjC 对 <code>objc_msgSend</code> 以及  <code>cache_getImp</code> 使用了汇编语言来编写。</p>
<p>如果你想了解有关 <code>objc_msgSend</code> 方法的汇编实现的信息，可以看这篇文章 <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html" target="_blank" rel="noopener">Let’s Build objc_msgSend</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章与其说是讲 ObjC 中的消息发送的过程，不如说是讲方法的实现是如何查找的。</p>
<p>Objective-C 中实现查找的路径还是比较符合直觉的：</p>
<ol>
<li>缓存命中</li>
<li>查找当前类的缓存及方法</li>
<li>查找父类的缓存及方法</li>
<li>方法决议</li>
<li>消息转发</li>
</ol>
<p>文章中关于方法调用栈的视频最开始是用 gif 做的，不过由于 gif 时间较长，试了很多的 gif 转换器，都没有得到一个较好的质量和合适的大小，所以最后选择用一个 Youtube 的视频。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html" target="_blank" rel="noopener">Let’s Build objc_msgSend</a></li>
</ul>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/从源代码看 ObjC 中消息的发送/" data-id="cjw6zovua0003bn0412ls24qw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-objc/你真的了解 load 方法么？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/你真的了解 load 方法么？/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="你真的了解-load-方法么？"><a href="#你真的了解-load-方法么？" class="headerlink" title="你真的了解 load 方法么？"></a>你真的了解 load 方法么？</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>文章的标题与其说是问各位读者，不如说是问笔者自己：<strong>我</strong>真的了解 <code>+ load</code> 方法么？</p>
</blockquote>
<p><code>+ load</code> 作为 Objective-C 中的一个方法，与其它方法有很大的不同。它只是一个<strong>在整个文件被加载到运行时，在 <code>main</code> 函数调用之前被 ObjC 运行时调用的钩子方法</strong>。其中关键字有这么几个：</p>
<ul>
<li>文件刚加载</li>
<li><code>main</code> 函数之前</li>
<li>钩子方法</li>
</ul>
<p>我在阅读 ObjC 源代码之前，曾经一度感觉自己对 <code>+ load</code> 方法的作用非常了解，直到看了源代码中的实现，才知道以前的以为，只是自己的以为罢了。</p>
<p>这篇文章会假设你知道：</p>
<ul>
<li>使用过 <code>+ load</code> 方法</li>
<li>知道 <code>+ load</code> 方法的调用顺序（文章中会简单介绍）</li>
</ul>
<p>在这篇文章中并不会用大篇幅介绍 <code>+ load</code> 方法的作用<del>其实也没几个作用</del>，关注点主要在以下两个问题上：</p>
<ul>
<li><code>+ load</code> 方法是如何被调用的</li>
<li><code>+ load</code> 方法为什么会有这种调用顺序</li>
</ul>
<h2 id="load-方法的调用栈"><a href="#load-方法的调用栈" class="headerlink" title="load 方法的调用栈"></a>load 方法的调用栈</h2><p>首先来通过 <code>load</code> 方法的调用栈，分析一下它到底是如何被调用的。</p>
<p>下面是程序的全部代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"XXObject load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码总共只实现了一个 <code>XXObject</code> 的 <code>+ load</code> 方法，主函数中也没有任何的东西：</p>
<p><img src="../images/objc-load-print-load.png" alt="objc-load-print-load"></p>
<p>虽然在主函数中什么方法都没有调用，但是运行之后，依然打印了 <code>XXObject load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p>
<h3 id="使用符号断点"><a href="#使用符号断点" class="headerlink" title="使用符号断点"></a>使用符号断点</h3><p>使用 Xcode 添加一个符号断点 <code>+[XXObject load]</code>：</p>
<blockquote>
<p>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p>
</blockquote>
<p><img src="../images/objc-load-symbolic-breakpoint.png" alt="objc-load-symbolic-breakpoint"></p>
<blockquote>
<p>为什么要加一个符号断点呢？因为这样看起来比较高级。</p>
</blockquote>
<p>重新运行程序。这时，代码会停在 <code>NSLog(@&quot;XXObject load&quot;);</code> 这一行的实现上：</p>
<p><img src="../images/objc-load-break-after-add-breakpoint.png" alt="objc-load-break-after-add-breakpoint"></p>
<p>左侧的调用栈很清楚的告诉我们，哪些方法被调用了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  +[XXObject load]</span><br><span class="line"><span class="number">1</span>  call_class_loads()</span><br><span class="line"><span class="number">2</span>  call_load_methods</span><br><span class="line"><span class="number">3</span>  load_images</span><br><span class="line"><span class="number">4</span>  dyld::notifySingle(dyld_image_states, ImageLoader <span class="keyword">const</span>*)</span><br><span class="line"><span class="number">11</span> _dyld_start</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html" target="_blank" rel="noopener">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。</p>
<p>在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。本文不会对其进行解释</p>
</blockquote>
<p>每当有新的镜像加载之后，都会执行 <code>3 load_images</code> 方法进行回调，这里的回调是在整个运行时初始化时 <code>_objc_init</code> 注册的（会在之后的文章中具体介绍）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br></pre></td></tr></table></figure>
<p>有新的镜像被加载到 runtime 时，调用 <code>load_images</code> 方法，并传入最新镜像的信息列表 <code>infoList</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">load_images(<span class="keyword">enum</span> dyld_image_states state, uint32_t infoCount,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">struct</span> dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> found;</span><br><span class="line"></span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; infoCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasLoadMethods((<span class="keyword">const</span> headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        call_load_methods();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是镜像"><a href="#什么是镜像" class="headerlink" title="什么是镜像"></a>什么是镜像</h3><p>这里就会遇到一个问题：镜像到底是什么，我们用一个断点打印出所有加载的镜像：</p>
<p><img src="../images/objc-load-print-image-info.png" alt="objc-load-print-image-info"></p>
<p>从控制台输出的结果大概就是这样的，我们可以看到镜像并不是一个 Objective-C 的代码文件，它应该是一个 target 的编译产物。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">(<span class="keyword">const</span> dyld_image_info) $<span class="number">52</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x00007fff8a144000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff8a144168</span> <span class="string">"/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices"</span></span><br><span class="line">  imageFileModDate = <span class="number">1452737802</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">const</span> dyld_image_info) $<span class="number">53</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x00007fff946d9000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff946d9480</span> <span class="string">"/usr/lib/liblangid.dylib"</span></span><br><span class="line">  imageFileModDate = <span class="number">1452737618</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">const</span> dyld_image_info) $<span class="number">54</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x00007fff88016000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff88016d40</span> <span class="string">"/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation"</span></span><br><span class="line">  imageFileModDate = <span class="number">1452737917</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">const</span> dyld_image_info) $<span class="number">55</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x0000000100000000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff5fbff8f0</span> <span class="string">"/Users/apple/Library/Developer/Xcode/DerivedData/objc-dibgivkseuawonexgbqssmdszazo/Build/Products/Debug/debug-objc"</span></span><br><span class="line">  imageFileModDate = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有很多的动态链接库，还有一些苹果为我们提供的框架，比如 Foundation、 CoreServices 等等，都是在这个 <code>load_images</code> 中加载进来的，而这些 <code>imageFilePath</code> 都是对应的<strong>二进制文件</strong>的地址。</p>
<p>但是如果进入最下面的这个目录，会发现它是一个<strong>可执行文件</strong>，它的运行结果与 Xcode 中的运行结果相同：</p>
<p><img src="../images/objc-load-image-binary.png" alt="objc-load-image-binary"></p>
<h3 id="准备-load-方法"><a href="#准备-load-方法" class="headerlink" title="准备 + load 方法"></a>准备 + load 方法</h3><p>我们重新回到 <code>load_images</code> 方法，如果在扫描镜像的过程中发现了 <code>+ load</code> 符号：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; infoCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasLoadMethods((<span class="keyword">const</span> headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会进入 <code>load_images_nolock</code> 来查找 <code>load</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> load_images_nolock(<span class="keyword">enum</span> dyld_image_states state,uint32_t infoCount,</span><br><span class="line">                   <span class="keyword">const</span> <span class="keyword">struct</span> dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">NO</span>;</span><br><span class="line">    uint32_t i;</span><br><span class="line"></span><br><span class="line">    i = infoCount;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> headerType *mhdr = (headerType*)infoList[i].imageLoadAddress;</span><br><span class="line">        <span class="keyword">if</span> (!hasLoadMethods(mhdr)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        prepare_load_methods(mhdr);</span><br><span class="line">        found = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>prepare_load_methods</code> 对 <code>load</code> 方法的调用进行准备（将需要调用 <code>load</code> 方法的类添加到一个列表中，后面的小节中会介绍）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> <strong>递归地安排当前类和没有调用 <code>+ load</code> 父类</strong>进入列表。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行 <code>add_class_to_loadable_list(cls)</code> 将当前类加入加载列表之前，会<strong>先把父类加入待加载的列表</strong>，保证父类在子类前调用 <code>load</code> 方法。</p>
<h3 id="调用-load-方法"><a href="#调用-load-方法" class="headerlink" title="调用 + load 方法"></a>调用 + load 方法</h3><p>在将镜像加载到运行时、对 <code>load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>load</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的调用流程大概是这样的：</p>
<p><img src="../images/objc-load-diagram.png" alt="objc-load-diagra"></p>
<p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后找到 <code>@selector(load)</code> 的实现并执行。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = <span class="literal">nil</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行 <code>(*load_method)(cls, SEL_load)</code> 代码就会调用 <code>+[XXObject load]</code> 方法。</p>
<blockquote>
<p>我们会在下面介绍 <code>loadable_classes</code> 列表是如何管理的。</p>
</blockquote>
<p>到现在，我们回答了第一个问题：</p>
<p>Q：<strong><code>load</code> 方法是如何被调用的？</strong></p>
<p>A：当 Objective-C 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入<em>运行时</em>的时候，进行回调。执行 <code>load_images</code> 将所有包含 <code>load</code> 方法的文件加入列表 <code>loadable_classes</code> ，然后从这个列表中找到对应的 <code>load</code> 方法的实现，调用 <code>load</code> 方法。</p>
<h2 id="加载的管理"><a href="#加载的管理" class="headerlink" title="加载的管理"></a>加载的管理</h2><p>ObjC 对于加载的管理，主要使用了两个列表，分别是 <code>loadable_classes</code> 和 <code>loadable_categories</code>。</p>
<p>方法的调用过程也分为两个部分，准备 <code>load</code> 方法和调用 <code>load</code> 方法，我更觉得这两个部分比较像生产者与消费者：</p>
<p><img src="../images/objc-load-producer-consumer-diagram.png" alt="objc-load-producer-consumer-diagra"></p>
<p><code>add_class_to_loadable_list</code> 方法负责将类加入 <code>loadable_classes</code> 集合，而 <code>call_class_loads</code> 负责消费集合中的元素。</p>
<p>而对于分类来说，其模型也是类似的，只不过使用了另一个列表 <code>loadable_categories</code>。</p>
<h3 id="“生产”-loadable-class"><a href="#“生产”-loadable-class" class="headerlink" title="“生产” loadable_class"></a>“生产” loadable_class</h3><p>在调用 <code>load_images -&gt; load_images_nolock -&gt; prepare_load_methods -&gt; schedule_class_load -&gt; add_class_to_loadable_list</code> 的时候会将未加载的类添加到 <code>loadable_classes</code> 数组中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法刚被调用时：</p>
<ol>
<li>会从 <code>class</code> 中获取 <code>load</code> 方法： <code>method = cls-&gt;getLoadMethod();</code></li>
<li>判断当前 <code>loadable_classes</code> 这个数组是否已经被全部占用了：<code>loadable_classes_used == loadable_classes_allocated</code></li>
<li>在当前数组的基础上扩大数组的大小：<code>realloc</code></li>
<li>把传入的 <code>class</code> 以及对应的方法的实现加到列表中</li>
</ol>
<p>另外一个用于保存分类的列表 <code>loadable_categories</code> 也有一个类似的方法 <code>add_category_to_loadable_list</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> add_category_to_loadable_list(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_categories = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现几乎与 <code>add_class_to_loadable_list</code> 完全相同。</p>
<p>到这里我们完成了对 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 的提供，下面会开始消耗列表中的元素。</p>
<h3 id="“消费”-loadable-class"><a href="#“消费”-loadable-class" class="headerlink" title="“消费” loadable_class"></a>“消费” loadable_class</h3><p>调用 <code>load</code> 方法的过程就是“消费” <code>loadable_classes</code> 的过程，<code>load_images -&gt; call_load_methods -&gt; call_class_loads</code> 会从 <code>loadable_classes</code> 中取出对应类和方法，执行 <code>load</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法对所有在 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 中的类以及分类执行 <code>load</code> 方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        call_class_loads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br></pre></td></tr></table></figure>
<p>调用顺序如下：</p>
<ol>
<li>不停调用类的 <code>+ load</code> 方法，直到 <code>loadable_classes</code> 为空</li>
<li>调用<strong>一次</strong> <code>call_category_loads</code> 加载分类</li>
<li>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>load</code> 方法</li>
</ol>
<p>相比于类 <code>load</code> 方法的调用，分类中 <code>load</code> 方法的调用就有些复杂了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, shift;</span><br><span class="line">    <span class="keyword">bool</span> new_categories_added = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// 1. 获取当前可以加载的分类列表</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_category *cats = loadable_categories;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果当前类是可加载的 `cls  &amp;&amp;  cls-&gt;isLoadable()` 就会调用分类的 load 方法</span></span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将所有加载过的分类移除 `loadable_categories` 列表</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 为 `loadable_categories` 重新分配内存，并重新设置它的值</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">        loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有些长，我们来分步解释方法的作用：</p>
<ol>
<li>获取当前可以加载的分类列表</li>
<li>如果当前类是可加载的 <code>cls  &amp;&amp;  cls-&gt;isLoadable()</code> 就会调用分类的 <code>load</code> 方法</li>
<li>将所有加载过的分类移除 <code>loadable_categories</code> 列表</li>
<li>为 <code>loadable_categories</code> 重新分配内存，并重新设置它的值</li>
</ol>
<h2 id="调用的顺序"><a href="#调用的顺序" class="headerlink" title="调用的顺序"></a>调用的顺序</h2><p>你过去可能会听说过，对于 <code>load</code> 方法的调用顺序有两条规则：</p>
<ol>
<li>父类先于子类调用</li>
<li>类先于分类调用</li>
</ol>
<p>这种现象是非常符合我们的直觉的，我们来分析一下这种现象出现的原因。</p>
<p>第一条规则是由于 <code>schedule_class_load</code> 有如下的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过这行代码 <code>schedule_class_load(cls-&gt;superclass)</code> 总是能够保证没有调用 <code>load</code> 方法的父类先于子类加入 <code>loadable_classes</code> 数组，从而确保其调用顺序的正确性。</p>
<p>类与分类中 <code>load</code> 方法的调用顺序主要在 <code>call_load_methods</code> 中实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        call_class_loads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br></pre></td></tr></table></figure>
<p>上面的 <code>do while</code> 语句能够在一定程度上确保，类的 <code>load</code> 方法会先于分类调用。但是这里不能完全保证调用顺序的正确。</p>
<p>如果<strong>分类的镜像在类的镜像之前加载到运行时</strong>，上面的代码就没法保证顺序的正确了，所以，我们还需要在 <code>call_category_loads</code> 中判断类是否已经加载到内存中（调用 <code>load</code> 方法）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">    (*load_method)(cls, SEL_load);</span><br><span class="line">    cats[i].cat = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，检查了类是否存在并且是否可以加载，如果都为真，那么就可以调用分类的 load 方法了。</p>
<h2 id="load-的应用"><a href="#load-的应用" class="headerlink" title="load 的应用"></a>load 的应用</h2><p><code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p>
<p>由于它的调用不是<em>惰性</em>的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="noopener">方法调剂</a>的绝佳时机。</p>
<p>但是由于 <code>load</code> 方法的运行时间过早，所以这里可能不是一个理想的环境，因为<strong>某些类可能需要在在其它类之前加载</strong>，但是这是我们无法保证的。不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" target="_blank" rel="noopener">NSObject +load and +initialize - What do they do?</a></li>
<li><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="noopener">Method Swizzling</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html" target="_blank" rel="noopener">Objective-C Class Loading and Initialization</a></li>
</ul>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/你真的了解 load 方法么？/" data-id="cjw6zovub0004bn04fy5mg415" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-objc/从 NSObject 的初始化了解 isa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/从 NSObject 的初始化了解 isa/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="从-NSObject-的初始化了解-isa"><a href="#从-NSObject-的初始化了解-isa" class="headerlink" title="从 NSObject 的初始化了解 isa"></a>从 NSObject 的初始化了解 isa</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<p>如果你曾经对 ObjC 底层的实现有一定的了解，你应该会知道 <strong>Objective-C 对象都是 C 语言结构体</strong>，所有的对象都包含一个类型为  <code>isa</code> 的指针，那么你可能确实对 ObjC 的底层有所知，不过现在的 ObjC 对象的结构已经不是这样了。代替 <code>isa</code> 指针的是结构体 <code>isa_t</code>, 这个结构体中”包含”了当前对象指向的类的信息，这篇文章中会介绍一些关于这个变化的知识。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 ObjC 为一个对象分配内存，初始化实例变量后，在这些对象的实例变量的结构体中的第一个就是 <code>isa</code>。</p>
<p><img src="../images/objc-isa-class-object.png" alt="objc-isa-class-object"></p>
<blockquote>
<p>所有继承自 <code>NSObject</code> 的类实例化后的对象都会包含一个类型为 <code>isa_t</code> 的结构体。</p>
</blockquote>
<p>从上图中可以看出，不只是<strong>实例</strong>会包含一个 <code>isa</code> 结构体，所有的<strong>类</strong>也有这么一个 <code>isa</code>。在 ObjC 中 Class 的定义也是一个名为 <code>objc_class</code> 的结构体，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 <code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的，所以在这里显式地写出了 <code>isa_t isa</code> 这个成员变量。</p>
</blockquote>
<h2 id="isa-指针的作用与元类"><a href="#isa-指针的作用与元类" class="headerlink" title="isa 指针的作用与元类"></a><code>isa</code> 指针的作用与元类</h2><p>到这里，我们就明白了：<strong>Objective-C 中类也是一个对象</strong>。</p>
<p>这个 <code>isa</code> 包含了什么呢？回答这个问题之前，要引入了另一个概念 <em>元类(meta class)</em>，我们先了解一些关于元类的信息。</p>
<p>因为在 Objective-C 中，对象的方法并<strong>没有存储于对象的结构体中</strong>（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p>
<p>当<strong>实例方法</strong>被调用时，它要通过自己持有的 <code>isa</code> 来查找对应的类，然后在这里的 <code>class_data_bits_t</code> 结构体中查找对应方法的实现。同时，每一个 <code>objc_class</code> 也有一个<strong>指向自己的父类的指针</strong> <code>super_class</code> 用来查找继承的方法。</p>
<blockquote>
<p>关于如何在 <code>class_data_bits_t</code> 中查找对应方法会在之后的文章中讲到。这里只需要知道，它会在这个结构体中查找到对应方法的实现就可以了。<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a></p>
</blockquote>
<p><img src="../images/objc-isa-class-pointer.png" alt="objc-isa-class-pointer"></p>
<p>但是，这样就有一个问题，类方法的实现又是如何查找并且调用的呢？这时，就需要引入<em>元类</em>来保证无论是类还是对象都能<strong>通过相同的机制查找方法的实现</strong>。</p>
<p><img src="../images/objc-isa-meta-class.png" alt="objc-isa-meta-class"></p>
<p>让每一个类的 <code>isa</code> 指向对应的元类，这样就达到了使类方法和实例方法的调用机制相同的目的：</p>
<ul>
<li>实例方法调用时，通过对象的 <code>isa</code> 在类中获取方法的实现</li>
<li>类方法调用时，通过类的 <code>isa</code> 在元类中获取方法的实现</li>
</ul>
<p>下面这张图介绍了对象，类与元类之间的关系，笔者认为已经觉得足够清晰了，所以不在赘述。</p>
<p><img src="../images/objc-isa-class-diagram.png" alt></p>
<blockquote>
<p>图片来自 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">objc_explain_Classes_and_metaclasses</a></p>
</blockquote>
<p>有关与介绍类与元类之间的关系的文章实在是太多了，因为这篇文章主要介绍 <code>isa</code>，在这一小节只是对其作用以及元类的概念进行介绍。如果想要了解更多关于类与元类的信息，可以看 <a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></p>
<h2 id="结构体-isa-t"><a href="#结构体-isa-t" class="headerlink" title="结构体 isa_t"></a>结构体 <code>isa_t</code></h2><p>其实 <code>isa_t</code> 是一个定义得非常”奇怪”的结构体，在 ObjC 源代码中可以看到这样的定义：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#define ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#define ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#define RC_ONE   (1ULL<span class="meta-string">&lt;&lt;56)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define RC_HALF  (1ULL&lt;&lt;7)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">union isa_t &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    isa_t() &#123; &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    Class cls;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    uintptr_t bits;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    struct &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t indexed           : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_assoc         : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_cxx_dtor      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t shiftcls          : 44;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t magic             : 6;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t weakly_referenced : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t deallocating      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_sidetable_rc  : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t extra_rc          : 8;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是在 <code>__x86_64__</code> 上的实现，对于 iPhone5s 等架构为 <code>__arm64__</code> 的设备上，具体结构体的实现和位数可能有些差别，不过这些字段都是存在的，可以看这里的 <a href="#arm64">arm64 上结构体的实现</a></p>
</blockquote>
<p><strong>在本篇文章中, 我们会以 <code>__x86_64__</code> 为例进行分析，而不会对两种架构下由于不同的内存布局方式导致的差异进行分析</strong>。在我看来，这个细节不会影响对 <code>isa</code> 指针的理解，不过还是要知道的。</p>
<p>笔者对这个 <code>isa_t</code> 的实现声明顺序有一些更改，更方便分析和理解。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>isa_t</code> 是一个 <code>union</code> 类型的结构体，对 <code>union</code> 不熟悉的读者可以看这个 stackoverflow 上的<a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" target="_blank" rel="noopener">回答</a>. 也就是说其中的 <code>isa_t</code>、<code>cls</code>、 <code>bits</code> 还有结构体共用同一块地址空间。而 <code>isa</code> 总共会占据 64 位的内存空间（决定于其中的结构体）</p>
<p><img src="../images/objc-isa-isat.png" alt="objc-isa-isat"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">   uintptr_t shiftcls          : <span class="number">44</span>;</span><br><span class="line">   uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">   uintptr_t extra_rc          : <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="isa-的初始化"><a href="#isa-的初始化" class="headerlink" title="isa 的初始化"></a><code>isa</code> 的初始化</h2><p>我们可以通过 <code>isa</code> 初始化的方法 <code>initIsa</code> 来初步了解这 64 位的 bits 的作用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="indexed-和-magic"><a href="#indexed-和-magic" class="headerlink" title="indexed 和 magic"></a><code>indexed</code> 和 <code>magic</code></h3><p>当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 <code>initIsa</code> 方法，由于在 <code>initInstanceIsa</code> 方法中传入了 <code>indexed = true</code>，所以，我们简化一下这个方法的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">    isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">    isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对整个 <code>isa</code> 的值 <code>bits</code> 进行设置，传入 <code>ISA_MAGIC_VALUE</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br></pre></td></tr></table></figure>
<p>我们可以把它转换成二进制的数据，然后看一下哪些属性对应的位被这行代码初始化了（标记为红色）：</p>
<p><img src="../images/objc-isa-isat-bits.png" alt="objc-isa-isat-bits"></p>
<p>从图中了解到，在使用 <code>ISA_MAGIC_VALUE</code> 设置 <code>isa_t</code> 结构体之后，实际上只是设置了 <code>indexed</code> 以及 <code>magic</code> 这两部分的值。</p>
<ul>
<li><p>其中 <code>indexed</code> 表示 <code>isa_t</code> 的类型</p>
<ul>
<li><p>0 表示 <code>raw isa</code>，也就是没有结构体的部分，访问对象的 <code>isa</code> 会直接返回一个指向 <code>cls</code> 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1 表示当前 <code>isa</code> 不是指针，但是其中也有 <code>cls</code> 的信息，只是其中<strong>关于类的指针都是保存在 <code>shiftcls</code> 中</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">44</span>;</span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>magic</code> 的值为 <code>0x3b</code> 用于调试器判断当前对象是真的对象还是没有初始化的空间</p>
</li>
</ul>
<h3 id="has-cxx-dtor"><a href="#has-cxx-dtor" class="headerlink" title="has_cxx_dtor"></a><code>has_cxx_dtor</code></h3><p>在设置 <code>indexed</code> 和 <code>magic</code> 值之后，会设置 <code>isa</code> 的 <code>has_cxx_dtor</code>，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.has_cxx_dtor = hasCxxDtor;</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-isa-isat-bits-has-css-dtor.png" alt="objc-isa-isat-bits-has-css-dto"></p>
<h3 id="shiftcls"><a href="#shiftcls" class="headerlink" title="shiftcls"></a><code>shiftcls</code></h3><p>在为 <code>indexed</code>、 <code>magic</code> 和 <code>has_cxx_dtor</code> 设置之后，我们就要将当前对象对应的类指针存入 <code>isa</code> 结构体中了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0</strong>。</p>
<p>绝大多数机器的架构都是 <a href="https://en.wikipedia.org/wiki/Byte_addressing" target="_blank" rel="noopener">byte-addressable</a> 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 <code>000</code>，我们只会用其中的 30 位来表示对象的地址。 </p>
</blockquote>
<p>而 ObjC 中的类指针的地址后三位也为 0，在 <code>_class_createInstanceFromZone</code> 方法中打印了调用这个方法传入的类指针：</p>
<p><img src="../images/objc-isa-print-cls.png" alt="objc-isa-print-cls"></p>
<p>可以看到，这里打印出来的<strong>所有类指针十六进制地址的最后一位都为 8 或者 0</strong>。也就是说，类指针的后三位都为 0，所以，我们在上面存储 <code>Class</code> 指针时右移三位是没有问题的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>如果再尝试打印对象指针的话，会发现所有对象内存地址的<strong>后四位</strong>都是 0，说明 ObjC 在初始化内存时是以 16 个字节对齐的, 分配的内存地址后四位都是 0。 </p>
<p><img src="../images/objc-isa-print-object.png" alt="objc-isa-print-object"></p>
<blockquote>
<p>使用整个指针大小的内存来存储 <code>isa</code> 指针有些浪费，尤其在 64 位的 CPU 上。在 <code>ARM64</code> 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 <code>isa</code> 留下 34 位用于性能的优化。</p>
<p>Using an entire pointer-sized piece of memory for the isa pointer is a bit wasteful, especially on 64-bit CPUs which don’t use all 64 bits of a pointer. ARM64 running iOS currently uses only 33 bits of a pointer, leaving 31 bits for other purposes. Class pointers are also aligned, meaning that a class pointer is guaranteed to be divisible by 8, which frees up another three bits, leaving 34 bits of the isa available for other uses. Apple’s ARM64 runtime takes advantage of this for some great performance improvements.<br>from <a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" target="_blank" rel="noopener">ARM64 and You</a></p>
</blockquote>
<p>我尝试运行了下面的代码将 <code>NSObject</code> 的类指针和对象的 <code>isa</code> 打印出来，具体分析一下</p>
<p><img src="../images/objc-isa-print-class-object.png" alt="objc-isa-print-class-object"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object_pointer: 0000000001011101100000000000000100000000001110101110000011111001 // 补全至 64 位</span><br><span class="line">class_pointer:                                 100000000001110101110000011111000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器对直接访问 <code>isa</code> 的操作会有警告，因为直接访问 <code>isa</code> 已经不会返回类指针了，这种行为已经被弃用了，取而代之的是使用 <a href="#ISA(">ISA()</a>) 方法来获取类指针。</p>
</blockquote>
<p>代码中的 <code>object</code> 对象的 <code>isa</code> 结构体中的内容是这样的：</p>
<p><img src="../images/objc-isa-isat-class-highlight-bits.png" alt="objc-isa-isat-class-highlight-bits"></p>
<p>其中红色的为<strong>类指针</strong>，与上面打印出的 <code>[NSObject class]</code> 指针右移三位的结果完全相同。这也就验证了我们之前对于初始化 <code>isa</code> 时对 <code>initIsa</code> 方法的分析是正确的。它设置了 <code>indexed</code>、<code>magic</code> 以及 <code>shiftcls</code>。</p>
<h3 id="ISA-方法"><a href="#ISA-方法" class="headerlink" title="ISA() 方法"></a><a id="ISA()"></a>ISA() 方法</h3><p>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 <code>ISA()</code> 来返回类指针。</p>
<p>其中 <code>ISA_MASK</code> 是宏定义，这里通过掩码的方式获取类指针：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISA_MASK 0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它-bits"><a href="#其它-bits" class="headerlink" title="其它 bits"></a>其它 bits</h3><p>在 <code>isa_t</code> 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p>
<ul>
<li><code>has_assoc</code><ul>
<li>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li>
</ul>
</li>
<li><code>weakly_referenced</code><ul>
<li>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li>
</ul>
</li>
<li><code>deallocating</code><ul>
<li>对象正在释放内存</li>
</ul>
</li>
<li><code>has_sidetable_rc</code><ul>
<li>对象的引用计数太大了，存不下</li>
</ul>
</li>
<li><code>extra_rc</code><ul>
<li>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，<code>extra_rc</code> 的值就为 9</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">   uintptr_t shiftcls          : <span class="number">44</span>;</span><br><span class="line">   uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">   uintptr_t extra_rc          : <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="arm64-架构中的-isa-t-结构体"><a href="#arm64-架构中的-isa-t-结构体" class="headerlink" title="arm64 架构中的 isa_t 结构体"></a><a id="arm64"></a>arm64 架构中的 <code>isa_t</code> 结构体</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#define ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#define ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#define RC_ONE   (1ULL<span class="meta-string">&lt;&lt;45)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define RC_HALF  (1ULL&lt;&lt;18)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">union isa_t &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    isa_t() &#123; &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    Class cls;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    uintptr_t bits;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    struct &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t indexed           : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t has_assoc         : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t has_cxx_dtor      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t shiftcls          : 33;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t magic             : 6;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t weakly_referenced : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t deallocating      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t has_sidetable_rc  : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">       uintptr_t extra_rc          : 19;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">objc_explain_Classes_and_metaclasses</a></li>
<li><a href="http://stackoverflow.com/questions/18997362/storing-things-in-isa" target="_blank" rel="noopener">Storing things in isa</a></li>
<li><a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" target="_blank" rel="noopener">Why do we need C Unions?</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">objc_explain_Non-pointer_isa</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="noopener">Tagged Pointer</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" target="_blank" rel="noopener">ARM64 and You</a></li>
<li><a href="http://blog.xcodev.com/posts/tagged-pointer-and-64-bit/" target="_blank" rel="noopener">64位与Tagged Pointer</a></li>
</ul>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/从 NSObject 的初始化了解 isa/" data-id="cjw6zovuc0005bn04x8uyebig" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-objc/对象是如何初始化的（iOS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/对象是如何初始化的（iOS）/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对象是如何初始化的（iOS）"><a href="#对象是如何初始化的（iOS）" class="headerlink" title="对象是如何初始化的（iOS）"></a>对象是如何初始化的（iOS）</h1><p>在之前，我们已经讨论了非常多的问题了，关于 objc 源代码系列的文章也快结束了，其实关于对象是如何初始化的这篇文章本来是我要写的第一篇文章，但是由于有很多前置内容不得不说，所以留到了这里。</p>
<p><code>+ alloc</code> 和 <code>- init</code> 这一对我们在 iOS 开发中每天都要用到的初始化方法一直困扰着我, 于是笔者仔细研究了一下 objc 源码中 <code>NSObject</code> 如何进行初始化。</p>
<p>在具体分析对象的初始化过程之前，我想先放出结论，以免文章中的细枝末节对读者的理解有所影响；整个对象的初始化过程其实只是<strong>为一个分配内存空间，并且初始化 isa_t 结构体的过程</strong>。</p>
<h2 id="alloc-方法分析"><a href="#alloc-方法分析" class="headerlink" title="alloc 方法分析"></a>alloc 方法分析</h2><p>先来看一下 <code>+ alloc</code> 方法的调用栈(在调用栈中省略了很多不必要的方法的调用):</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> _objc_rootAlloc(Class cls)</span><br><span class="line">└── <span class="keyword">static</span> <span class="keyword">id</span> callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">    └── <span class="keyword">id</span> class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">    	└── <span class="keyword">id</span> _class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, <span class="keyword">bool</span> cxxConstruct, size_t *outAllocatedSize)</span><br><span class="line">            ├── size_t instanceSize(size_t extraBytes)</span><br><span class="line">            ├── <span class="keyword">void</span>	*calloc(size_t, size_t)</span><br><span class="line">            └── <span class="keyword">inline</span> <span class="keyword">void</span> objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br></pre></td></tr></table></figure>
<p>这个调用栈中的方法涉及了多个文件中的代码，在下面的章节中会对调用的方法逐步进行分析，如果这个调用栈让你觉得很头疼，也不是什么问题。</p>
<h3 id="alloc-的实现"><a href="#alloc-的实现" class="headerlink" title="alloc 的实现"></a>alloc 的实现</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alloc</code> 方法的实现真的是非常的简单, 它直接调用了另一个私有方法 <code>id _objc_rootAlloc(Class cls)</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> _objc_rootAlloc(Class cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是上帝类 <code>NSObject</code> 对 <code>callAlloc</code> 的实现，我们省略了非常多的代码，展示了最常见的执行路径：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> class_createInstance(Class cls, size_t extraBytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象初始化中最重要的操作都在 <code>_class_createInstanceFromZone</code> 方法中执行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, size_t *outAllocatedSize = <span class="literal">nil</span>) &#123;</span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象的大小"><a href="#对象的大小" class="headerlink" title="对象的大小"></a>对象的大小</h3><p>在使用 <code>calloc</code> 为对象分配一块内存空间之前，我们要先获取对象在内存的大小：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint32_t unalignedInstanceSize() &#123;</span><br><span class="line">    assert(isRealized());</span><br><span class="line">    <span class="keyword">return</span> data()-&gt;ro-&gt;instanceSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例大小 <code>instanceSize</code> 会存储在类的 <code>isa_t</code> 结构体中，然后经过对齐最后返回。</p>
<blockquote>
<p>Core Foundation 需要所有的对象的大小都必须大于或等于 16 字节。</p>
</blockquote>
<p>在获取对象大小之后，直接调用 <code>calloc</code> 函数就可以为对象分配内存空间了。</p>
<h3 id="isa-的初始化"><a href="#isa-的初始化" class="headerlink" title="isa 的初始化"></a>isa 的初始化</h3><p>在对象的初始化过程中除了使用 <code>calloc</code> 来分配内存之外，还需要根据类初始化 <code>isa_t</code> 结构体：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor) &#123; </span><br><span class="line">    <span class="keyword">if</span> (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码只是对 <code>isa_t</code> 结构体进行初始化而已：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">   isa_t() &#123; &#125;</span><br><span class="line">   isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">   Class cls;</span><br><span class="line">   uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">struct</span> &#123;</span><br><span class="line">       uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">       uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">       uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">       uintptr_t shiftcls          : <span class="number">44</span>;</span><br><span class="line">       uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">       uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">       uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">       uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">       uintptr_t extra_rc          : <span class="number">8</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里并不想过多介绍关于 <code>isa_t</code> 结构体的内容，你可以看<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a> 来了解你想知道的关于 <code>isa_t</code> 的全部内容。</p>
</blockquote>
<h2 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h2><p><code>NSObject</code> 的 <code>- init</code> 方法只是调用了 <code>_objc_rootInit</code> 并返回了当前对象：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> _objc_rootInit(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 iOS 中一个对象的初始化过程很符合直觉，只是分配内存空间、然后初始化 <code>isa_t</code> 结构体，其实现也并不复杂，这篇文章也是这个系列文章中较为简单并且简短的一篇。</p>
<blockquote>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">Draveness · Github</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/对象是如何初始化的（iOS）/" data-id="cjw6zovud0006bn04enm75wib" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-objc/懒惰的 initialize 方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/懒惰的 initialize 方法/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="懒惰的-initialize-方法"><a href="#懒惰的-initialize-方法" class="headerlink" title="懒惰的 initialize 方法"></a>懒惰的 initialize 方法</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章可能是对 Objective-C 源代码解析系列文章中最短的一篇了，在 Objective-C 中，我们总是会同时想到 <code>load</code>、<code>initialize</code> 这两个类方法。而这两个方法也经常在一起比较：</p>
<p>在上一篇介绍 <code>load</code> 方法的<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/你真的了解%20load%20方法么？.md" target="_blank" rel="noopener">文章</a>中，已经对 <code>load</code> 方法的调用时机、调用顺序进行了详细地分析，所以对于 <code>load</code> 方法，这里就不在赘述了。</p>
<p>这篇文章会<del>假设你知道：</del>假设你是 iOS 开发者。</p>
<p>本文会主要介绍：</p>
<ol>
<li><code>initialize</code> 方法的调用为什么是惰性的</li>
<li>这货能干啥</li>
</ol>
<h2 id="initialize-的调用栈"><a href="#initialize-的调用栈" class="headerlink" title="initialize 的调用栈"></a>initialize 的调用栈</h2><p>在分析其调用栈之前，首先来解释一下，什么是惰性的。</p>
<p>这是 <code>main.m</code> 文件中的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"XXObject initialize"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数中的代码为空，如果我们运行这个程序：</p>
<p><img src="../images/objc-initialize-print-nothing.png" alt="objc-initialize-print-nothing"></p>
<p>你会发现与 <code>load</code> 方法不同的是，虽然我们在 <code>initialize</code> 方法中调用了 <code>NSLog</code>。但是程序运行之后没有任何输出。</p>
<p>如果，我们在自动释放池中加入以下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __unused XXObject *object = [[XXObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再运行程序：</p>
<p><img src="../images/objc-initialize-print-initialize.png" alt="objc-initialize-print-initialize"></p>
<p>你会发现，虽然我们没有直接调用 <code>initialize</code> 方法。但是，这里也打印出了 <code>XXObject initialize</code> 字符串。</p>
<blockquote>
<p><code>initialize</code> <strong>只会在对应类的方法第一次被调用时，才会调用</strong>。</p>
</blockquote>
<p>我们在 <code>initialize</code> 方法中打一个断点，来查看这个方法的调用栈：</p>
<p><img src="../images/objc-initialize-breakpoint.png" alt="objc-initialize-breakpoint"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> +[XXObject initialize]</span><br><span class="line"><span class="number">1</span> _class_initialize</span><br><span class="line"><span class="number">2</span> lookUpImpOrForward</span><br><span class="line"><span class="number">3</span> _class_lookupMethodAndLoadCache3</span><br><span class="line"><span class="number">4</span> objc_msgSend</span><br><span class="line"><span class="number">5</span> main</span><br><span class="line"><span class="number">6</span> start</span><br></pre></td></tr></table></figure>
<p>直接来看调用栈中的 <code>lookUpImpOrForward</code> 方法，<code>lookUpImpOrForward</code> 方法<strong>只会在向对象发送消息，并且在类的缓存中没有找到消息的选择子时</strong>才会调用，具体可以看这篇文章，<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从源代码看%20ObjC%20中消息的发送.md" target="_blank" rel="noopener">从源代码看 ObjC 中消息的发送</a>。</p>
<p>在这里，我们知道 <code>lookUpImpOrForward</code> 方法是 <code>objc_msgSend</code> 触发的就够了。</p>
<p><img src="../images/objc-initialize-print-selector.png" alt="objc-initialize-print-selecto"></p>
<p>在 lldb 中输入 <code>p sel</code> 打印选择子，会发现当前调用的方法是 <code>alloc</code> 方法，也就是说，<code>initialize</code> 方法是在 <code>alloc</code> 方法之前调用的，<code>alloc</code> 的调用导致了前者的执行。</p>
<p>其中，使用 <code>if (initialize  &amp;&amp;  !cls-&gt;isInitialized())</code> 来判断当前类是否初始化过：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isInitialized() &#123;</span><br><span class="line">   <span class="keyword">return</span> getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前类是否初始化过的信息就保存在<a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">元类</a>的 <code>class_rw_t</code> 结构体中的 <code>flags</code> 中。</p>
</blockquote>
<p>这是 <code>flags</code> 中保存的信息，它记录着跟当前类的元数据，其中第 16-31 位有如下的作用：</p>
<p><img src="../images/objc-initialize-class_rw_t_-bits-flag.png" alt="objc-initialize-class_rw_t_-bits-flag"></p>
<p><code>flags</code> 的第 29 位 <code>RW_INITIALIZED</code> 就保存了当前类是否初始化过的信息。</p>
<h2 id="class-initialize-方法"><a href="#class-initialize-方法" class="headerlink" title="_class_initialize 方法"></a>_class_initialize 方法</h2><p>在 <code>initialize</code> 的调用栈中，直接调用其方法的是下面的这个 C 语言函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="built_in">BOOL</span> reallyInitialize = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 强制父类先调用 initialize 方法</span></span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. 通过加锁来设置 RW_INITIALIZING 标志位</span></span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        <span class="keyword">if</span> (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) &#123;</span><br><span class="line">        <span class="comment">// 3. 成功设置标志位，向当前类发送 +initialize 消息</span></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 完成初始化，如果父类已经初始化完成，设置 RW_INITIALIZED 标志位，</span></span><br><span class="line">        <span class="comment">//    否则，在父类初始化完成之后再设置标志位。</span></span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        <span class="keyword">if</span> (!supercls  ||  supercls-&gt;isInitialized()) &#123;</span><br><span class="line">            _finishInitializing(cls, supercls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _finishInitializingAfter(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cls-&gt;isInitializing()) &#123;</span><br><span class="line">        <span class="comment">// 5. 当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回</span></span><br><span class="line">        <span class="keyword">if</span> (_thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            monitor_locker_t lock(classInitLock);</span><br><span class="line">            <span class="keyword">while</span> (!cls-&gt;isInitialized()) &#123;</span><br><span class="line">                classInitLock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        <span class="comment">// 6. 初始化成功后，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _objc_fatal(<span class="string">"thread-safe class init in objc runtime is buggy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的主要作用自然是向未初始化的类发送 <code>+initialize</code> 消息，不过会强制父类先发送 <code>+initialize</code>。</p>
<ol>
<li><p>强制<strong>未初始化过的</strong>父类调用 <code>initialize</code> 方法</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">    _class_initialize(supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过加锁来设置 <code>RW_INITIALIZING</code> 标志位</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">monitor_locker_t lock(classInitLock);</span><br><span class="line"><span class="keyword">if</span> (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">    cls-&gt;setInitializing();</span><br><span class="line">    reallyInitialize = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功设置标志位、向当前类发送 <code>+initialize</code> 消息</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成初始化，如果父类已经初始化完成，设置 <code>RW_INITIALIZED</code> 标志位。否则，在父类初始化完成之后再设置标志位</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">monitor_locker_t lock(classInitLock);</span><br><span class="line"><span class="keyword">if</span> (!supercls  ||  supercls-&gt;isInitialized()) &#123;</span><br><span class="line">    _finishInitializing(cls, supercls);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _finishInitializingAfter(cls, supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回，<strong>保证线程安全</strong></p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    monitor_locker_t lock(classInitLock);</span><br><span class="line">    <span class="keyword">while</span> (!cls-&gt;isInitialized()) &#123;</span><br><span class="line">        classInitLock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化成功后，直接返回</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="管理初始化队列"><a href="#管理初始化队列" class="headerlink" title="管理初始化队列"></a>管理初始化队列</h2><p>因为我们始终要保证父类的初始化方法要在子类之前调用，所以我们需要维护一个 <code>PendingInitializeMap</code> 的数据结构来存储<strong>当前的类初始化需要哪个父类先初始化完成</strong>。</p>
<p><img src="../images/PendingInitializeMap.png" alt="PendingInitializeMap"></p>
<p>这个数据结构中的信息会被两个方法改变：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!supercls  ||  supercls-&gt;isInitialized()) &#123;</span><br><span class="line">  _finishInitializing(cls, supercls);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  _finishInitializingAfter(cls, supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别是 <code>_finishInitializing</code> 以及 <code>_finishInitializingAfter</code>，先来看一下后者是怎么实现的，也就是<strong>在父类没有完成初始化的时候</strong>调用的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _finishInitializingAfter(Class cls, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending;</span><br><span class="line">    pending = (PendingInitialize *)malloc(<span class="keyword">sizeof</span>(*pending));</span><br><span class="line">    pending-&gt;subclass = cls;</span><br><span class="line">    pending-&gt;next = (PendingInitialize *)NXMapGet(pendingInitializeMap, supercls);</span><br><span class="line">    NXMapInsert(pendingInitializeMap, supercls, pending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为当前类的父类没有初始化，所以会将子类加入一个数据结构 <code>PendingInitialize</code> 中，这个数据结构其实就类似于一个保存子类的链表。这个链表会以父类为键存储到 <code>pendingInitializeMap</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NXMapInsert(pendingInitializeMap, supercls, pending);</span><br></pre></td></tr></table></figure>
<p>而在<strong>父类已经调用了初始化方法</strong>的情况下，对应方法 <code>_finishInitializing</code> 的实现就稍微有些复杂了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _finishInitializing(Class cls, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending;</span><br><span class="line"></span><br><span class="line">    cls-&gt;setInitialized();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!pendingInitializeMap) <span class="keyword">return</span>;</span><br><span class="line">    pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, cls);</span><br><span class="line">    <span class="keyword">if</span> (!pending) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    NXMapRemove(pendingInitializeMap, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pending) &#123;</span><br><span class="line">        PendingInitialize *next = pending-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (pending-&gt;subclass) _finishInitializing(pending-&gt;subclass, cls);</span><br><span class="line">        free(pending);</span><br><span class="line">        pending = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，由于父类已经完成了初始化，在这里直接将当前类标记成已经初始化，然后<strong>递归地将被当前类 block 的子类标记为已初始化</strong>，再把这些当类移除 <code>pendingInitializeMap</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们对 <code>initialize</code> 方法的研究基本上已经结束了，这里会总结一下关于其方法的特性：</p>
<ol>
<li><code>initialize</code> 的调用是惰性的，它会在第一次调用当前类的方法时被调用</li>
<li>与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都<strong>已经加载</strong>到了内存中</li>
<li><code>initialize</code> 的运行是线程安全的</li>
<li>子类会<strong>继承</strong>父类的 <code>initialize</code> 方法</li>
</ol>
<p>而其作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></li>
<li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" target="_blank" rel="noopener">NSObject +load and +initialize - What do they do?</a></li>
</ul>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/懒惰的 initialize 方法/" data-id="cjw6zovud0007bn04n0otnuxh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-objc/深入解析 ObjC 中方法的结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/objc/深入解析 ObjC 中方法的结构/" class="article-date">
  <time datetime="2017-08-28T00:13:52.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入解析-ObjC-中方法的结构"><a href="#深入解析-ObjC-中方法的结构" class="headerlink" title="深入解析 ObjC 中方法的结构"></a>深入解析 ObjC 中方法的结构</h1><blockquote>
<p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>
<p>在上一篇分析 <code>isa</code> 的文章<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a> 中曾经说到过实例方法被调用时，会通过其持有 <code>isa</code> 指针寻找对应的类，然后在其中的 <code>class_data_bits_t</code> 中查找对应的方法，在这一篇文章中会介绍方法在 ObjC 中是如何存储方法的。</p>
<p>这篇文章的首先会根据 ObjC 源代码来分析方法在内存中的存储结构，然后在 lldb 调试器中一步一步验证分析的正确性。</p>
<h2 id="方法在内存中的位置"><a href="#方法在内存中的位置" class="headerlink" title="方法在内存中的位置"></a>方法在内存中的位置</h2><p>先来了解一下 ObjC 中类的结构图：</p>
<p><img src="../images/objc-method-class.png" alt="objc-method-class"></p>
<ul>
<li><code>isa</code> 是指向元类的指针，不了解元类的可以看 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">Classes and Metaclasses</a></li>
<li><code>super_class</code> 指向当前类的父类</li>
<li><code>cache</code> 用于缓存指针和 <code>vtable</code>，加速方法的调用</li>
<li><code>bits</code> 就是存储类的方法、属性和遵循的协议等信息的地方</li>
</ul>
<h3 id="class-data-bits-t-结构体"><a href="#class-data-bits-t-结构体" class="headerlink" title="class_data_bits_t 结构体"></a><code>class_data_bits_t</code> 结构体</h3><p>这一小结会分析类结构体中的 <code>class_data_bits_t bits</code>。</p>
<p>下面就是 ObjC 中 <code>class_data_bits_t</code> 的结构体，其中只含有一个 64 位的 <code>bits</code> 用于存储与类有关的信息：</p>
<p><img src="../images/objc-method-class-data-bits-t.png" alt="objc-method-class-data-bits-t"></p>
<p>在 <code>objc_class</code> 结构体中的注释写到 <code>class_data_bits_t</code> 相当于 <code>class_rw_t</code> 指针加上 rr/alloc 的标志。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br></pre></td></tr></table></figure>
<p>它为我们提供了便捷方法用于返回其中的 <code>class_rw_t *</code> 指针：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span><br><span class="line">   <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>bits</code> 与 <code>FAST_DATA_MASK</code> 进行位运算，只取其中的 <code>[3, 47]</code> 位转换成 <code>class_rw_t *</code> 返回。</p>
<blockquote>
<p>在 x86_64 架构上，Mac OS <strong>只使用了其中的 47 位来为对象分配地址</strong>。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。</p>
</blockquote>
<p>因为 <code>class_rw_t *</code> 指针只存于第 <code>[3, 47]</code> 位，所以可以使用最后三位来存储关于当前类的其他信息：</p>
<p><img src="../images/objc-method-class_data_bits_t.png" alt="objc-method-class_data_bits_t"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define FAST_IS_SWIFT           (1UL<span class="meta-string">&lt;&lt;0)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>isSwift()</code><ul>
<li><code>FAST_IS_SWIFT</code> 用于判断 Swift 类</li>
</ul>
</li>
<li><code>hasDefaultRR()</code><ul>
<li><code>FAST_HAS_DEFAULT_RR</code> 当前类或者父类含有默认的 <code>retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</li>
</ul>
</li>
<li><code>requiresRawIsa()</code><ul>
<li><code>FAST_REQUIRES_RAW_ISA</code> 当前类的实例需要 raw <code>isa</code></li>
</ul>
</li>
</ul>
<p>执行 <code>class_data_bits_t</code> 结构体中的 <code>data()</code> 方法或者调用 <code>objc_class</code> 中的 <code>data()</code> 方法会返回同一个 <code>class_rw_t *</code> 指针，因为 <code>objc_class</code> 中的方法只是对 <code>class_data_bits_t</code> 中对应方法的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// objc_class 中的 data() 方法</span><br><span class="line">class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t *data() &#123; </span><br><span class="line">   return bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class_data_bits_t 中的 data() 方法</span><br><span class="line">uintptr_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">   return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class-rw-t-和-class-ro-t"><a href="#class-rw-t-和-class-ro-t" class="headerlink" title="class_rw_t 和 class_ro_t"></a><code>class_rw_t</code> 和 <code>class_ro_t</code></h3><p>ObjC 类中的属性、方法还有遵循的协议等信息都保存在 <code>class_rw_t</code> 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中还有一个指向常量的指针 <code>ro</code>，其中存储了<strong>当前类在编译期就已经确定的属性、方法以及遵循的协议</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">    uint32_t reserved;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>在编译期间</strong>类的结构中的 <code>class_data_bits_t *data</code> 指向的是一个 <code>class_ro_t *</code> 指针：</p>
<p><img src="../images/objc-method-before-realize.png" alt="objc-method-before-realize"></p>
<p>然后在加载 <em>ObjC 运行时</em>的时候调用 <code>realizeClass</code> 方法：</p>
<ol>
<li>从 <code>class_data_bits_t</code> 调用 <code>data</code> 方法，将结果从 <code>class_rw_t</code> 强制转换为 <code>class_ro_t</code> 指针</li>
<li>初始化一个 <code>class_rw_t</code> 结构体</li>
<li>设置结构体 <code>ro</code> 的值以及 <code>flag</code></li>
<li>最后设置正确的 <code>data</code>。</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> class_ro_t *ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">class_rw_t *rw = (class_rw_t *)calloc(<span class="keyword">sizeof</span>(class_rw_t), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure>
<p>下图是 <code>realizeClass</code> 方法执行过后的类所占用内存的布局，你可以与上面调用方法前的内存布局对比以下，看有哪些更改：</p>
<p><img src="../images/objc-method-after-realize-class.png" alt="objc-method-after-realize-class"></p>
<p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p>
<h2 id="XXObject"><a href="#XXObject" class="headerlink" title="XXObject"></a>XXObject</h2><p>下面，我们将分析一个类 <code>XXObject</code> 在运行时初始化过程中内存的更改，这是 <code>XXObject</code> 的接口与实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h 文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码是运行在 Mac OS X 10.11.3 (x86_64)版本中，而不是运行在 iPhone 模拟器或者真机上的，如果你在 iPhone 或者真机上运行，可能有一定差别。</p>
</blockquote>
<p><img src="../images/objc-method-target.png" alt="objc-method-target"></p>
<p>这是主程序的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XXObject.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Class cls = [XXObject class];</span><br><span class="line">        NSLog(@&quot;%p&quot;, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译后内存中类的结构"><a href="#编译后内存中类的结构" class="headerlink" title="编译后内存中类的结构"></a>编译后内存中类的结构</h3><p>因为<strong>类在内存中的位置是编译期就确定的</strong>，先运行一次代码获取 <code>XXObject</code> 在内存中的地址。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100001168</span></span><br></pre></td></tr></table></figure>
<p>接下来，在整个 ObjC 运行时初始化之前，也就是 <code>_objc_init</code> 方法中加入一个断点：</p>
<p><img src="../images/objc-method-after-compile.png" alt="objc-method-after-compile"></p>
<p>然后在 lldb 中输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)0x100001168</span><br><span class="line">(objc_class *) $0 = 0x0000000100001168</span><br><span class="line">(lldb) p (class_data_bits_t *)0x100001188</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100001188</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">warning: could not load any Objective-C class information. This will significantly reduce the quality of type information available.</span><br><span class="line">(class_rw_t *) $2 = 0x00000001000010e8</span><br><span class="line">(lldb) p (class_ro_t *)$2 // 将 class_rw_t 强制转化为 class_ro_t</span><br><span class="line">(class_ro_t *) $3 = 0x00000001000010e8</span><br><span class="line">(lldb) p *$3</span><br><span class="line">(class_ro_t) $4 = &#123;</span><br><span class="line">  flags = 128</span><br><span class="line">  instanceStart = 8</span><br><span class="line">  instanceSize = 8</span><br><span class="line">  reserved = 0</span><br><span class="line">  ivarLayout = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  name = 0x0000000100000f7a &quot;XXObject&quot;</span><br><span class="line">  baseMethodList = 0x00000001000010c8</span><br><span class="line">  baseProtocols = 0x0000000000000000</span><br><span class="line">  ivars = 0x0000000000000000</span><br><span class="line">  weakIvarLayout = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  baseProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-method-lldb-print-before-realize.png" alt="objc-method-lldb-print-before-realize"></p>
<p>现在我们获取了类经过编译器处理后的只读属性 <code>class_ro_t</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(class_ro_t) $<span class="number">4</span> = &#123;</span><br><span class="line">  flags = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  name = <span class="number">0x0000000100000f7a</span> <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0x00000001000010c8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里面只有 <code>baseMethodList</code> 和 <code>name</code> 是有值的，其它的 <code>ivarLayout</code>、 <code>baseProtocols</code>、 <code>ivars</code>、<code>weakIvarLayout</code> 和 <code>baseProperties</code> 都指向了空指针，因为类中没有实例变量，协议以及属性。所以这里的结构体符合我们的预期。</p>
<p>通过下面的命令查看 <code>baseMethodList</code> 中的内容：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $<span class="number">4.</span>baseMethodList</span><br><span class="line">(method_list_t *) $<span class="number">5</span> = <span class="number">0x00000001000010c8</span></span><br><span class="line">(lldb) p $<span class="number">5</span>-&gt;get(<span class="number">0</span>)</span><br><span class="line">(method_t) $<span class="number">6</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = <span class="number">0x0000000100000fa4</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100000e90</span> (method`-[XXObject hello] at XXObject.m:<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">5</span>-&gt;get(<span class="number">1</span>)</span><br><span class="line">Assertion failed: (i &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.h, line <span class="number">110.</span></span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-method-lldb-print-method-list.png" alt="objc-method-lldb-print-method-list"></p>
<p>使用 <code>$5-&gt;get(0)</code> 时，成功获取到了 <code>-[XXObject hello]</code> 方法的结构体 <code>method_t</code>。而尝试获取下一个方法时，断言提示我们当前类只有一个方法。</p>
<h3 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h3><p>这篇文章中不会对 <code>realizeClass</code> 进行详细的分析，该方法的主要作用是对类进行第一次初始化，其中包括：</p>
<ul>
<li>分配可读写数据空间</li>
<li>返回真正的类结构</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClass(Class cls)</span><br></pre></td></tr></table></figure>
<p>上面就是这个方法的签名，我们需要在这个方法中打一个条件断点，来判断当前类是否为 <code>XXObject</code>：</p>
<p><img src="../images/objc-method-lldb-breakpoint.png" alt="objc-method-lldb-breakpoint"></p>
<p>这里直接判断两个指针是否相等，而不使用 <code>[NSStringFromClass(cls) isEqualToString:@&quot;XXObject&quot;]</code> 是因为在这个时间点，这些方法都不能调用，在 ObjC 中没有这些方法，所以只能通过判断类指针是否相等的方式来确认当前类是 <code>XXObject</code>。</p>
<blockquote>
<p>直接与指针比较是因为类在内存中的位置是编译期确定的，只要代码不改变，类在内存中的位置就会不变（已经说过很多遍了）。</p>
</blockquote>
<p><img src="../images/objc-method-breakpoint-before-set-rw.png" alt="objc-method-breakpoint-before-set-r"></p>
<p>这个断点就设置在这里，因为 <code>XXObject</code> 是一个正常的类，所以会走 <code>else</code> 分支为<strong>可写的类数据</strong>分配内存。</p>
<blockquote>
<p>运行代码时，因为每次都会判断当前类指针是不是指向的 <code>XXObject</code>，所以会等一会才会进入断点。</p>
</blockquote>
<p>在这时打印类结构体中的 <code>data</code> 的值，发现其中的布局依旧是这样的：</p>
<p><img src="../images/objc-method-before-realize.png" alt="objc-method-before-realize"></p>
<p>在运行完这段代码之后:</p>
<p><img src="../images/objc-method-after-realize-breakpoint.png" alt="objc-method-after-realize-breakpoint"></p>
<p>我们再来打印类的结构:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)cls <span class="comment">// 打印类指针</span></span><br><span class="line">(objc_class *) $<span class="number">262</span> = <span class="number">0x0000000100001168</span></span><br><span class="line">(lldb) p (class_data_bits_t *)<span class="number">0x0000000100001188</span> <span class="comment">// 在类指针上加 32 的 offset 打印 class_data_bits_t 指针</span></span><br><span class="line">(class_data_bits_t *) $<span class="number">263</span> = <span class="number">0x0000000100001188</span></span><br><span class="line">(lldb) p *$<span class="number">263</span> <span class="comment">// 访问 class_data_bits_t 指针的内容</span></span><br><span class="line">(class_data_bits_t) $<span class="number">264</span> = (bits = <span class="number">4302315312</span>)</span><br><span class="line">(lldb) p $<span class="number">264.</span>data() <span class="comment">// 获取 class_rw_t</span></span><br><span class="line">(class_rw_t *) $<span class="number">265</span> = <span class="number">0x0000000100701f30</span></span><br><span class="line">(lldb) p *$<span class="number">265</span> <span class="comment">// 访问 class_rw_t 指针的内容，发现它的 ro 已经设置好了</span></span><br><span class="line">(class_rw_t) $<span class="number">266</span> = &#123;</span><br><span class="line">  flags = <span class="number">2148007936</span></span><br><span class="line">  version = <span class="number">0</span></span><br><span class="line">  ro = <span class="number">0x00000001000010e8</span></span><br><span class="line">  methods = &#123;</span><br><span class="line">    list_array_tt&lt;method_t, method_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000000000000</span></span><br><span class="line">        arrayAndFlag = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  properties = &#123;</span><br><span class="line">    list_array_tt&lt;property_t, property_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000000000000</span></span><br><span class="line">        arrayAndFlag = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  protocols = &#123;</span><br><span class="line">    list_array_tt&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, protocol_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        list = <span class="number">0x0000000000000000</span></span><br><span class="line">        arrayAndFlag = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = <span class="literal">nil</span></span><br><span class="line">  nextSiblingClass = <span class="literal">nil</span></span><br><span class="line">  demangledName = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">266.</span>ro <span class="comment">// 获取 class_ro_t 指针</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t *) $<span class="number">267</span> = <span class="number">0x00000001000010e8</span></span><br><span class="line">(lldb) p *$<span class="number">267</span> <span class="comment">// 访问 class_ro_t 指针的内容</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t) $<span class="number">268</span> = &#123;</span><br><span class="line">  flags = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  name = <span class="number">0x0000000100000f7a</span> <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0x00000001000010c8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">268.</span>baseMethodList <span class="comment">// 获取基本方法列表</span></span><br><span class="line">(method_list_t *<span class="keyword">const</span>) $<span class="number">269</span> = <span class="number">0x00000001000010c8</span></span><br><span class="line">(lldb) p $<span class="number">269</span>-&gt;get(<span class="number">0</span>) <span class="comment">// 访问第一个方法</span></span><br><span class="line">(method_t) $<span class="number">270</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = <span class="number">0x0000000100000fa4</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100000e90</span> (method`-[XXObject hello] at XXObject.m:<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">269</span>-&gt;get(<span class="number">1</span>) <span class="comment">// 尝试访问第二个方法，越界</span></span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">Assertion failed: (i &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.h, line <span class="number">110.</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
<p><img src="../images/objc-method-print-class-struct-after-realize.png" alt="objc-method-print-class-struct-after-realize"></p>
<blockquote>
<p>最后一个操作实在是截取不到了</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> class_ro_t *ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">class_rw_t *rw = (class_rw_t *)calloc(<span class="keyword">sizeof</span>(class_rw_t), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure>
<p>在上述的代码运行之后，类的只读指针 <code>class_ro_t</code> 以及可读写指针 <code>class_rw_t</code> 都被正确的设置了。但是到这里，其 <code>class_rw_t</code> 部分的方法等成员的指针 <code>methods</code>、 <code>protocols</code> 和 <code>properties</code> 均为空，这些会在 <code>methodizeClass</code> 中进行设置：</p>
<p><img src="../images/objc-method-after-methodizeClass.png" alt="objc-method-after-methodizeClass"></p>
<p>在这里调用了 <code>method_array_t</code> 的 <code>attachLists</code> 方法，将 <code>baseMethods</code> 中的方法添加到 <code>methods</code> 数组之后。我们访问 <code>methods</code> 才会获取当前类的实例方法。</p>
<h2 id="方法的结构"><a href="#方法的结构" class="headerlink" title="方法的结构"></a>方法的结构</h2><p>说了这么多，到现在我们可以简单看一下方法的结构，与类和对象一样，方法在内存中也是一个结构体。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中包含方法名，类型还有方法的实现指针 <code>IMP</code>：</p>
<p><img src="../images/obj-method-struct.png" alt="obj-method-struct"></p>
<p>上面的 <code>-[XXObject hello]</code> 方法的结构体是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"hello"</span></span><br><span class="line">types = <span class="number">0x0000000100000fa4</span> <span class="string">"v16@0:8"</span></span><br><span class="line">imp = <span class="number">0x0000000100000e90</span> (method`-[XXObject hello] at XXObject.m:<span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>方法的名字在这里没有什么好说的。其中，方法的类型是一个非常奇怪的字符串 <code>&quot;v16@0:8&quot;</code> 这在 ObjC 中叫做<em>类型编码</em>(Type Encoding)，你可以看这篇<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">官方文档</a>了解与类型编码相关的信息。</p>
<p>对于方法的实现，lldb 为我们标注了方法在文件中实现的位置。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分析方法在内存中的位置时，笔者最开始一直在尝试寻找<strong>只读</strong>结构体 <code>class_ro_t</code> 中 <code>baseMethods</code> 第一次设置的位置（了解类的方法是如何被加载的）。尝试从 <code>methodizeClass</code> 方法一直向上找，直到 <code>_obj_init</code> 方法也没有找到设置只读区域的 <code>baseMethods</code> 的方法。</p>
<p>而且在 runtime 初始化之后，<code>realizeClass</code> 之前，从 <code>class_data_bits_t</code> 结构体中获取的 <code>class_rw_t</code> 一直都是错误的，这个问题在最开始非常让我困惑，直到后来在 <code>realizeClass</code> 中发现原来在这时并不是 <code>class_rw_t</code> 结构体，而是<code>class_ro_t</code>，才明白错误的原因。</p>
<p>后来突然想到类的一些方法、属性和协议实在编译期决定的（<code>baseMethods</code> 等成员以及类在内存中的位置都是编译期决定的），才感觉到豁然开朗。</p>
<ol>
<li>类在内存中的位置是在编译期间决定的，在之后修改代码，也不会改变内存中的位置。</li>
<li>类的方法、属性以及协议在编译期间存放到了“错误”的位置，直到 <code>realizeClass</code> 执行之后，才放到了 <code>class_rw_t</code> 指向的只读区域 <code>class_ro_t</code>，这样我们即可以在运行时为 <code>class_rw_t</code> 添加方法，也不会影响类的只读结构。</li>
<li>在 <code>class_ro_t</code> 中的属性在运行期间就不能改变了，再添加方法时，会修改 <code>class_rw_t</code> 中的 <code>methods</code> 列表，而不是 <code>class_ro_t</code> 中的 <code>baseMethods</code>，对于方法的添加会在之后的文章中分析。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">Classes and Metaclasses</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="noopener">Tagged Pointer</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">类型编码</a></li>
<li><a href="http://nshipster.cn/type-encodings/" target="_blank" rel="noopener">Type Encodings</a></li>
</ul>
<p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://caofuqing.com/2017/08/28/objc/深入解析 ObjC 中方法的结构/" data-id="cjw6zovue0008bn042lx2wgc1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/27/hello-world/">Hello World caofuqing</a>
          </li>
        
          <li>
            <a href="/2019/05/27/iOS面试题整理/">iOS面试题整理</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/上古时代 Objective-C 中哈希表的实现/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/从源代码看 ObjC 中消息的发送/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/08/28/objc/你真的了解 load 方法么？/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 talking<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>